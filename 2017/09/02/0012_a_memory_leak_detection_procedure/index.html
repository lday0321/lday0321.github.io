<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="lday" />



<meta name="description" content="最近在开发升级PubSub系统，目标是支持更新版本的kafka（从原来的支持kafka 0.8.2.2升级到支持较新版本的kafka 0.10.1.1）。由于kafka在0.9版本上对consumer group相关的结构进行了重构，原来使用的基于zk进行rebalance的consumer group client:wvanbergen/kafka已经不再适用。为此，我们调研并最终选用了支持新版">
<meta property="og:type" content="article">
<meta property="og:title" content="一次Golang程序内存泄漏分析之旅">
<meta property="og:url" content="http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/index.html">
<meta property="og:site_name" content="lday的博客">
<meta property="og:description" content="最近在开发升级PubSub系统，目标是支持更新版本的kafka（从原来的支持kafka 0.8.2.2升级到支持较新版本的kafka 0.10.1.1）。由于kafka在0.9版本上对consumer group相关的结构进行了重构，原来使用的基于zk进行rebalance的consumer group client:wvanbergen/kafka已经不再适用。为此，我们调研并最终选用了支持新版">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/01_2w_memory_leak.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/25_moni_arch.png?imageView2/2/w/700">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/02_mctl_status.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/03_mctl_sub_status.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/04_golang_grafana.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/05_go_tool_pprof.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/06_go_tool_pprof_profile.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/07_long_conn_pub_sub.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/08_short_conn_2r_test.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/09_short_conn_pub.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/10_short_conn_sub.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/11_short_conn_sub_longterm.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/12_goroutine_cnt.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/13_08_30_after_test_profile009.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/14_sarama_broker_open.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/15_sarama_broker_open_meter.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/16_goroutine_compare.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/17_meter_tick_goroutine.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/18_meter_global_list.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/19_meter_global_list_2.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/20_leak_issue.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/21_use_nil_metrics.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/22_nil_meter.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/23_vscode_GetOrRegsterMeter.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/24_goglang_GetOrRegsterMeter.png">
<meta property="og:updated_time" content="2017-09-01T19:12:01.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一次Golang程序内存泄漏分析之旅">
<meta name="twitter:description" content="最近在开发升级PubSub系统，目标是支持更新版本的kafka（从原来的支持kafka 0.8.2.2升级到支持较新版本的kafka 0.10.1.1）。由于kafka在0.9版本上对consumer group相关的结构进行了重构，原来使用的基于zk进行rebalance的consumer group client:wvanbergen/kafka已经不再适用。为此，我们调研并最终选用了支持新版">
<meta name="twitter:image" content="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/01_2w_memory_leak.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="lday的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>一次Golang程序内存泄漏分析之旅 | lday的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">lday</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Life, Coding, Funning</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atomic/">atomic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boost/">boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ds-algorithm/">ds_algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/">hello</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello1/">hello1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipc/">ipc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-barriers/">memory barriers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share-memory/">share memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">lday, 80后IT码农一枚. 白羊座，喜热闹</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">lday</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">lday</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Life, Coding, Funning</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-0012_a_memory_leak_detection_procedure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/02/0012_a_memory_leak_detection_procedure/" class="article-date">
      <time datetime="2017-09-01T18:49:14.000Z" itemprop="datePublished">2017-09-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一次Golang程序内存泄漏分析之旅
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近在开发升级PubSub系统，目标是支持更新版本的kafka（从原来的支持kafka 0.8.2.2升级到支持较新版本的kafka 0.10.1.1）。由于kafka在0.9版本上对consumer group相关的结构进行了<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Client-side+Assignment+Proposal" target="_blank" rel="external">重构</a>，原来使用的基于zk进行rebalance的<a href="https://github.com/wvanbergen/kafka" target="_blank" rel="external">consumer group client:wvanbergen/kafka</a>已经不再适用。为此，我们调研并最终选用了支持新版kafka consumer rebalance的<a href="https://github.com/bsm/sarama-cluster" target="_blank" rel="external">consumer group client:sarama-cluster</a>。功能开发已基本结束，目前已进入系统压力测试阶段。</p>
<a id="more"></a>
<p>花了二周时间，用golang完成了一个分布式的测试工具框架，满足我对PubSub系统大规模分布式并发压力测是的需求。同时，这段时间，我已经将PubSub系统部署起来，并通过一个监控程序每隔30s向目标topic发送pub和sub请求。一周后，当我打开监控面板，“期待已久”的幺蛾子出现了：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/01_2w_memory_leak.png" alt=""></p>
<p>从上图我们可以看出，在两周多的时间里，系统的堆内存画出了一条”完美”的增长曲线，WTF！</p>
<p>怀着无比激动的心情， 我开始了这次内存泄漏的分析之旅</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>工欲善其事，必先利其器。要想方便，快捷的定位、解决问题，首先你得有一套好使，方便的工具。</p>
<h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>我花2周时间写的分布式自动化测试工具正好派上了用场。简单的介绍一下我的分布自动化测试工具：“摸你”(moni)。由于时间原因，目前moni只实现了一些基础功能，不过，对于这次的目标已经够用了。moni是一套主-从结构的分布式测试工具。大致结构如下所示：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/25_moni_arch.png?imageView2/2/w/700" alt=""></p>
<p>moni分为三部分：</p>
<ul>
<li>mrunner，用于执行具体的测试任务，保存执行状态及结果。</li>
<li>mman，中心管理节点。用于向所有mrunner发布任务，并根据需求向mrunner抓取并汇总执行结果。同时提供RESTFul api，为终端用于提供接口，用于发布各类命令。</li>
<li>mctl，测试执行人操作工具，通过该工具调用mman的RESTFul接口，并最终将各测试命令下发至各mrunner。</li>
<li>magent，暂未实现。用于支持在大规模分布式环境下多台mrunner的自动升级和自动起、停，目前通过脚本半自动化来完成</li>
</ul>
<p>目前，mctl支持三类命令：</p>
<ol>
<li>status，收集查看moni各节点的状态</li>
<li>pub，执行pub测试，</li>
<li>sub，支持sub测试</li>
</ol>
<p>各命令又包含若干自参数，用于定制各类测试场景，通用的一些参数包括：</p>
<ul>
<li>-d: duration，用于设定测试时间长度</li>
<li>-i: interval, 用于设定请求间隔</li>
<li>-c：concurrency，用于设定并发量</li>
<li>-cm: connection mode，用于设定链接的类型（长链接or短连接）</li>
<li>等等</li>
</ul>
<p>mman与mrunner之间保持TCP长连接，mrunner会在与mman的连接断开后主动每间隔一定时间便尝试重连，并在每次连接成功后执行runner注册动作。mman同时作为一个http server，向mctl暴露HTTP的RESTFul接口，接收来自mctl的指令，并返回结果</p>
<p>查看mrunner整体情况：<br><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/02_mctl_status.png" alt=""></p>
<p>下图则是我在向13个runner下发了sub测试指令（持续12小时，每2s执行一次sub，并发量为1）之后，查看sub执行情况：<br><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/03_mctl_sub_status.png" alt=""></p>
<p>有了moni这套工具， 我就能很方便的模拟测试各类场景，帮助我重现系统的问题。</p>
<h3 id="数据采集、汇总工具"><a href="#数据采集、汇总工具" class="headerlink" title="数据采集、汇总工具"></a>数据采集、汇总工具</h3><p>仅仅有了模拟工具显然是不够的，作为系统自身，你还需要有一套完整的数据采集、汇总工具，通过这些工具，我们能收集系统的各类指标，并将这些指标最终展现出来，方便我们观察系统状态，定位系统问题。PubSub系统基于Golang实现，golang实际上提供了非常好的工具来帮助我们采集各类指标</p>
<h4 id="系统监控统计级别数据指标"><a href="#系统监控统计级别数据指标" class="headerlink" title="系统监控统计级别数据指标"></a>系统监控统计级别数据指标</h4><ol>
<li>goroutine数量</li>
<li>堆(heap)内存使用量</li>
<li>栈(stack)内存使用量</li>
<li>等等</li>
</ol>
<p>这些数据我们都将进行统计，并最终写入到influxdb中，并经由grafana展示出来</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/04_golang_grafana.png" alt=""></p>
<p>这些数据可以通过<a href="https://golang.org/pkg/runtime/" target="_blank" rel="external">runtime包</a>内的接口获得，当然，为获得各类型的统计值，使用封装好的库会是更加方便的选择：<a href="https://github.com/rcrowley/go-metrics" target="_blank" rel="external">rcrowley/go-metrics</a>。</p>
<h4 id="问题定位所需的详细数据"><a href="#问题定位所需的详细数据" class="headerlink" title="问题定位所需的详细数据"></a>问题定位所需的详细数据</h4><p>上述监控级指标，只能告诉你系统是不是出问题了，但是你很难从上述指标中定位出具体是哪里出了问题。在分析内存泄漏时，你不但要确定是否有内存泄漏，你还需要在发现存在内存泄漏时明确定位出在哪里出现了内存泄漏！ 这时候就需要使用一些更细的指标信息。golang已经为我们做好了准备，你可以：</p>
<ul>
<li>获取系统实时堆内存分配详细信息<br>具体到这块内存是在哪里分配的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">heap profile: 9: 8474736 [13: 8556768] @ heap/1048576</div><div class="line">2: 3145728 [2: 3145728] @ 0x791484 0x798931 0x45b621</div><div class="line">#	0x791483	github.com/ffan/xxx/vendor/github.com/samuel/go-zookeeper/zk.(*Conn).recvLoop+0x53	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxx/vendor/github.com/samuel/go-zookeeper/zk/conn.go:679</div><div class="line">#	0x798930	github.com/ffan/xxx/vendor/github.com/samuel/go-zookeeper/zk.(*Conn).loop.func2+0x40	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxx/vendor/github.com/samuel/go-zookeeper/zk/conn.go:424</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"># runtime.MemStats</div><div class="line"># Alloc = 13127416</div><div class="line"># TotalAlloc = 15482888</div><div class="line"># Sys = 21641464</div><div class="line"># Lookups = 126</div><div class="line"># Mallocs = 51022</div><div class="line"># Frees = 33571</div><div class="line"># HeapAlloc = 13127416</div><div class="line"># HeapSys = 15564800</div><div class="line"># HeapIdle = 1277952</div><div class="line"># HeapInuse = 14286848</div><div class="line"># HeapReleased = 0</div><div class="line"># HeapObjects = 17451</div><div class="line"># Stack = 1212416 / 1212416</div><div class="line"># MSpan = 54416 / 81920</div><div class="line"># MCache = 38400 / 49152</div><div class="line"># BuckHashSys = 1445508</div><div class="line"># GCSys = 796672</div><div class="line"># OtherSys = 2490996</div><div class="line"># NextGC = 101353464</div><div class="line"># PauseNs = [838359 1139459 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</div><div class="line"># NumGC = 2</div><div class="line"># DebugGC = false</div></pre></td></tr></table></figure>
<ul>
<li>获取系统实时所有goroutine调用栈信息<br>具体到这个goroutine是在哪里启动的，以及当前是在干什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">goroutine 1 [chan receive, 2 minutes]:</div><div class="line">github.com/ffan/xxx/cmd/kateway/gateway.(*Gateway).ServeForever(0xc4200aa0a0)</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxx/cmd/kateway/gateway/gateway.go:339 +0x65</div><div class="line">main.main()</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxx/cmd/kateway/main.go:101 +0x287</div><div class="line"></div><div class="line">goroutine 17 [syscall, 2 minutes, locked to thread]:</div><div class="line">runtime.goexit()</div><div class="line">	/home/chenlei106/Tools/Dev_Tools/go_1_8/src/runtime/asm_amd64.s:2197 +0x1</div></pre></td></tr></table></figure>
<ul>
<li>获取系统实时堆内存调优辅助统计信息<br>具体是在哪里分配了多少内存，以及top N分别是哪些，甚至是每个内存分配的来源图<br><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/05_go_tool_pprof.png" alt=""></li>
</ul>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/06_go_tool_pprof_profile.png" alt=""></p>
<p>让我们一个一个来看。</p>
<h5 id="获取系统实时堆内存分配详细信息"><a href="#获取系统实时堆内存分配详细信息" class="headerlink" title="获取系统实时堆内存分配详细信息"></a>获取系统实时堆内存分配详细信息</h5><p> 为了获取系统实时堆内存分配的详细信息，需要使用<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="external">net/http/pprof包</a>，通过该包，只要在我们的http server上注册指定的路由路径，就可以在访问路径时获取到实时的heap内存分配详细信息。</p>
<p>具体做法是：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引入pprof</span></div><div class="line"><span class="keyword">import</span> <span class="string">"net/http/pprof"</span></div><div class="line"></div><div class="line"><span class="comment">//在http router上加入</span></div><div class="line">this.debugMux.HandleFunc(<span class="string">"/debug/pprof/"</span>, http.HandlerFunc(pprof.Index))</div></pre></td></tr></table></figure></p>
<p>在启动server后，直接可以通过：<br><code>curl -XGET  &quot;http://192.168.149.150:10194/debug/pprof/heap?debug=2&quot;</code> 获取heap内存的详细信息，其中10194是你开启的http server的端口，debug=2意味着需要输出详细信息</p>
<h5 id="获取系统实时所有goroutine调用栈信息"><a href="#获取系统实时所有goroutine调用栈信息" class="headerlink" title="获取系统实时所有goroutine调用栈信息"></a>获取系统实时所有goroutine调用栈信息</h5><p>在完成<code>this.debugMux.HandleFunc(&quot;/debug/pprof/&quot;, http.HandlerFunc(pprof.Index))</code>注册后，实际上我们不光可以获取heap信息，我们也同样可以获得goroutine信息，只是最终的http路径不同而已，通过<code>curl -XGET  &quot;http://192.168.149.150:10194/debug/pprof/goroutine?debug=2&quot;</code>拿到的就是goroutine的详细信息</p>
<h5 id="获取系统实时堆内存调优辅助统计信息"><a href="#获取系统实时堆内存调优辅助统计信息" class="headerlink" title="获取系统实时堆内存调优辅助统计信息"></a>获取系统实时堆内存调优辅助统计信息</h5><p>基于上述由目标程序暴露的http接口，使用golang提供的工具，我们就能对统计信息进行分析：<code>go tool pprof -inuse_space http://192.168.149.150:10194/debug/pprof/heap</code>，进入pprof交互模式后，可以通过<code>top</code>, <code>tree</code>等进一步查看统计信息，同时，也可以通过<code>png</code>命令，将内存信息输出成图片，以图片的形式显示内存的分配、占用情况</p>
<h5 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h5><p>对于go pprof工具的具体使用，可参考golang官方blog的文章：<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">Profiling Go Programs</a>，或者郝林的中文说明：<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md" target="_blank" rel="external">go tool pprof</a></p>
<h2 id="模拟场景，重现问题"><a href="#模拟场景，重现问题" class="headerlink" title="模拟场景，重现问题"></a>模拟场景，重现问题</h2><h3 id="场景一：完全仿照之前的测试，通过长连接执行Pub-Sub调用"><a href="#场景一：完全仿照之前的测试，通过长连接执行Pub-Sub调用" class="headerlink" title="场景一：完全仿照之前的测试，通过长连接执行Pub/Sub调用"></a>场景一：完全仿照之前的测试，通过长连接执行Pub/Sub调用</h3><p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/07_long_conn_pub_sub.png" alt=""></p>
<p>经过两轮测试，我们发现，内存占用“似乎”有一定的变化，但又不是那么明显，此时我们无法确定是否真重现了内存泄漏的问题。</p>
<h3 id="场景二：改用短连接执行Pub-Sub调用"><a href="#场景二：改用短连接执行Pub-Sub调用" class="headerlink" title="场景二：改用短连接执行Pub/Sub调用"></a>场景二：改用短连接执行Pub/Sub调用</h3><p>仔细分析前两周PubSub系统的静默运行行为，我们发现，实际上当时的Pub采用的是长连接，而Sub实际上采用的是短连接模式。为此，我们调整了moni的测试连接模式，改成短连接模式</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/08_short_conn_2r_test.png" alt=""></p>
<p>如上图所示，在调整为短连接模式后，我们又执行了两轮测试，其中第一轮测试初始化时5个Pub，5个Sub，每个客户端分别以2s为间隔执行sub，在执行了40分钟后，我又进一步加大了压力。同理，第二轮测试与第一轮测试类似。从图上我们可以看出，换成短连接后，内存泄漏的现象已经被清晰的展示出来，其中每轮测试，内存泄漏量大致在20M之上</p>
<h3 id="场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏"><a href="#场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏" class="headerlink" title="场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏"></a>场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏</h3><p>为进一步确认是由Pub调用引起的内存泄漏，还是由Sub调用引起的内存泄漏，我们单独对Pub进行了测试，如下图所示，在单独执行pub的测试中，我们发现，pub对内存泄漏没有影响</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/09_short_conn_pub.png" alt=""></p>
<h3 id="场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏"><a href="#场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏" class="headerlink" title="场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏"></a>场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏</h3><p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/10_short_conn_sub.png" alt=""></p>
<p>在单独使用sub进行测试的过程中，我们明显发现了内存泄漏</p>
<h3 id="场景五：单独使用Sub调用，长时间压力测试"><a href="#场景五：单独使用Sub调用，长时间压力测试" class="headerlink" title="场景五：单独使用Sub调用，长时间压力测试"></a>场景五：单独使用Sub调用，长时间压力测试</h3><p>为进一步验证在sub上存在内存泄漏，我们对PubSub系统进行了2组长时间测试，每组测试10小时，12个sub，每2s执行一次sub</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/11_short_conn_sub_longterm.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述几轮的测试，基于收集到的数据，我们基本上已经明确：内存泄漏来自于短连接Sub操作。后续我们则需要针对性的对短连接sub的执行逻辑以及具体数据变化进行分析了</p>
<h2 id="获取数据，比对分析"><a href="#获取数据，比对分析" class="headerlink" title="获取数据，比对分析"></a>获取数据，比对分析</h2><p>golang是一门自带gc的语言，这也就意味着大多数情况下我们不需要过多的关心何时申请内存，何时释放内存。但是，即使是有gc，也不能排除像我们这次遇到的内存泄漏的问题。在有gc的场景下，内存泄漏主要是有一些对象，被“意外”的勾住，引用计数不为0，导致gc错误的认为对象正在使用，而无法回收。要让内存对象在异常情况下引用计数不为0，我认为无外乎有两种情况：</p>
<ol>
<li>有goroutine泄漏，goroutine“飞”了，zombie goroutine没有结束，这个时候在这个goroutine上分配的内存对象将一直被这个僵尸goroutine引用着，进而导致gc无法回收这类对象，内存泄漏。</li>
<li>有一些全局（或者生命周期和程序本身运行周期一样长的）的数据结构意外的挂住了本该释放的对象，虽然goroutine已经退出了，但是这些对象并没有从这类数据结构中删除，导致对象一直被引用，无法被回收。</li>
</ol>
<h3 id="确认goroutine是否泄漏"><a href="#确认goroutine是否泄漏" class="headerlink" title="确认goroutine是否泄漏"></a>确认goroutine是否泄漏</h3><p>为找出内存泄漏的来源，我们首先来确认goroutine是否存在泄漏问题。下图是我们整个测试周期内，PubSub系统goroutine的变化情况：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/12_goroutine_cnt.png" alt=""></p>
<p>从上图我们可以看出，整个测试过程中，goroutine数量会随着测试的推进而变化，但不会持续增长，同时，在sub测试结束后，goroutine的数量又会回落到初始化持平状态，goroutine数量基本没有变，通过goroutine数据的观察，我们可以确定，不存在goroutine泄漏。同时我们可以看到在之前有pub参与时，goroutine提升到了1k以上，但是在只有sub参与测试中，goroutine数量维持在了一个较低的水平（85左右）。之所有pub参与时，goroutine数量会上升，是因为PubSub系统对Pub调用构建了对象池，虽然pub动作是短连接，但是在PubSub系统中，和后台kafka连接的Broker对象并未关闭，这些对象被放在了对象池中，并未回收。而这些对象的生命周期内有存活的内部goroutine，因此，在有pub的测试中goroutine的数量明显更多。在有pub参与的测试结束后，我们通过<code>curl -XGET  &quot;http://192.168.149.150:10194/debug/pprof/goroutine?debug=2&quot;</code>拿到goroutine调用栈的信息时，可以看到很多类似的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">goroutine 9360181 [chan receive]:</div><div class="line">github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).responseReceiver(0xc42659c000)</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:484 +0xfa</div><div class="line">github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).(github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.responseReceiver)-fm()</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:148 +0x2a</div><div class="line">github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.withRecover(0xc426210ef0)</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/utils.go:46 +0x43</div><div class="line">created by github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).Open.func1</div><div class="line">	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:148 +0x910</div></pre></td></tr></table></figure></p>
<h3 id="确认内存泄漏的具体位置"><a href="#确认内存泄漏的具体位置" class="headerlink" title="确认内存泄漏的具体位置"></a>确认内存泄漏的具体位置</h3><p>gorutine既然没有泄漏，那内存泄漏只可能是第二种可能：有一些全局（或者生命周期和程序本身运行周期一样长的）的数据结构意外的挂住了本该释放的对象。为找到这个数据结构，我们需要先进一步所以范围：需确认被挂住的内存到底是在哪里</p>
<p>通过<code>go tool pprof</code>工具，以及从<code>curl -XGET  &quot;http://192.168.149.150:10194/debug/pprof/heap?debug=2&quot;</code>，我们获得了我们想要的数据。首先，我们通过<code>go tool pprof</code>工具查看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Entering interactive mode (type &quot;help&quot; for commands)</div><div class="line">(pprof) top 20</div><div class="line">939.05MB of 949.56MB total (98.89%)</div><div class="line">Dropped 464 nodes (cum &lt;= 4.75MB)</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">  486.54MB 51.24% 51.24%   912.56MB 96.10%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.newStandardMeter</div><div class="line">  150.51MB 15.85% 67.09%   150.51MB 15.85%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.NewEWMA1</div><div class="line">  140.01MB 14.74% 81.83%   140.01MB 14.74%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.NewEWMA15</div><div class="line">  135.51MB 14.27% 96.10%   135.51MB 14.27%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.NewEWMA5</div><div class="line">   26.48MB  2.79% 98.89%   939.05MB 98.89%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.NewMeter</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).Open.func1</div><div class="line">         0     0% 98.89%   612.02MB 64.45%  github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.getOrRegisterBrokerMeter</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.withRecover</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.(*StandardRegistry).GetOrRegister</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  github.com/ffan/xxxx/vendor/github.com/rcrowley/go-metrics.GetOrRegisterMeter</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  reflect.Value.Call</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  reflect.Value.call</div><div class="line">         0     0% 98.89%   939.05MB 98.89%  runtime.call32</div><div class="line">         0     0% 98.89%   948.06MB 99.84%  runtime.goexit</div></pre></td></tr></table></figure>
<p>从heap内存分布来看，大头出自：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">939.05MB 98.89%  github.com/ffan/gafka/vendor/github.com/Shopify/sarama.(*Broker).Open.func1</div></pre></td></tr></table></figure></p>
<p>通过在交互模式下生成png图片，我们进一步来看：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/13_08_30_after_test_profile009.png" alt=""></p>
<p>上图已经很明确的显示出，是在saram.Broker.Open函数中，New了各类Meter，而这些Meter就是内存泄漏的地方。同时，在我们通过<code>curl -XGET  &quot;http://192.168.149.150:10194/debug/pprof/heap?debug=2&quot;</code>收集的heap详细信息中，我们也可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#	0x69e3cc	github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).Open.func1+0x101c	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:118</div><div class="line">#	0x69e51c	github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).Open.func1+0x116c	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:121</div><div class="line">#	0x69dd6e	github.com/ffan/xxxx/vendor/github.com/Shopify/sarama.(*Broker).Open.func1+0x9be	/home/chenlei106/Works/GoWorks/PubSub_2/src/github.com/ffan/xxxx/vendor/github.com/Shopify/sarama/broker.go:148</div></pre></td></tr></table></figure></p>
<p>非常多的内存对象，来自broker.go:118/121/148中Broker.Open调用的meter创建</p>
<h3 id="深入分析内存泄漏的逻辑"><a href="#深入分析内存泄漏的逻辑" class="headerlink" title="深入分析内存泄漏的逻辑"></a>深入分析内存泄漏的逻辑</h3><p>从Broker的Open来看，Broker是通过起goroutine来申请的资源，最开始我是怀疑是由于Broker起了goroutine，但是没有close goroutine，导致内存泄漏。</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/14_sarama_broker_open.png" alt=""></p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/15_sarama_broker_open_meter.png" alt=""></p>
<p>从上面对goroutine数据的观察我们可以看出，在sub时，并没有goroutine泄漏。实际上，为了进一步确认Broker的关闭情况，我还开启了sarama的log，在broker open和close的地方进行了打点统计，统计的结果也的确是所有open的broker，最终均close掉。</p>
<p>我们只能进一步分析代码。说实话，分析到这里，对着代码走了一圈，也没看出有啥问题来（关键是代码那么多，哪里都有可能出问题，隐隐觉得应该是被什么东西挂住了，就是找不到，到底是什么东西挂住了这些资源！），倒腾了有一天，反复debug，反复比对数据，诶嘿，终于找到了！</p>
<p>其实最终的定位有些运气成分。在尝试了各种分析无果之后，无奈之下，我只能再次进行测试，收集数据，期望能从测试中发现一些不一样的痕迹来。这次测试和往期不同，这次测试，我首先把环境清理的干干净净，PubSub系统整个停掉，重新启动，并且，在执行任何测试之前，我先通过<code>http://192.168.149.150:10194/debug/pprof</code>收集了一把heap和goroutine的数据。然后再执行sub压力测试。在测试完之后，再度收集heap，goroutine的数据。前后比较了一番，我发现了goroutine上的蛛丝马迹！</p>
<p>在比对测试前后goroutine的信息时，我发现在测试结束后，尽然多出了一个非常可疑的goroutine：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/16_goroutine_compare.png" alt=""></p>
<p>之所以非常可疑，是因为这个tick的gorutine，就是在处理Meter相关的逻辑，和我们从heap信息中看到的泄漏数据非常吻合。为进一步确认，顺着代码，仔细看看：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/17_meter_tick_goroutine.png" alt=""></p>
<p>隐约感觉这个<code>ma.meters</code>就是勾住内存对象的某个全局变量，顺着函数，这货到底从何而来！</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/18_meter_global_list.png" alt=""></p>
<p><code>arbiter</code>是一个彻头彻尾的全局变量！</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/19_meter_global_list_2.png" alt=""></p>
<p>我擦擦擦，胜利就在眼前了！如果在<code>arbiter.meters = append(arbiter.meters, m)</code>之后，没有remove，那就有问题了！看着list append的动作，估计是没有remove，要是需要remove，一般会用map吧。搜了一圈代码，果真没有！ 那应该就是这里，导致memory leak了。</p>
<h2 id="确认问题，解决方案"><a href="#确认问题，解决方案" class="headerlink" title="确认问题，解决方案"></a>确认问题，解决方案</h2><p>问题基本上确定了， 为进一步肯定自己的推测，这个时候，我到<a href="https://github.com/rcrowley/go-metrics" target="_blank" rel="external">https://github.com/rcrowley/go-metrics</a> 查查issue list，看看有没有人有类似的问题</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/20_leak_issue.png" alt=""></p>
<p>果然，赫然在列！进一步，我们会看到sarama中和这个相关的issue:<br>问题根源：go-metrics存在内存泄漏！<br><a href="https://github.com/rcrowley/go-metrics/issues/201" target="_blank" rel="external">https://github.com/rcrowley/go-metrics/issues/201</a></p>
<p>引起在sarama频繁开启，关闭broker时，导致内存不断泄漏<br><a href="https://github.com/Shopify/sarama/issues/897" target="_blank" rel="external">https://github.com/Shopify/sarama/issues/897</a></p>
<p>go-metrics内存泄漏，证据确凿！！！</p>
<p>尽然已经发现问题了，下一步咱们得想办法解决掉他。从sarama相关issue的说明来看：</p>
<blockquote>
<p>It does not seem possible in go-metrics to unregister the meter and get that reference removed (even if we do not unregister the metrics in Sarama today)…</p>
<p>Note that we do not use timer metrics but that would result in the same issue as the StandardTimer struct uses a meter under the hood…</p>
<p>Looks like this needs to be fixed in go-metrics first and we would also have to use Registry#Unregister(string) or something</p>
</blockquote>
<p>换句话说，sarama得等go-metrics提供了修复内存泄漏的Unregister接口后，在必要的地方(Broker Close的时候)Unregister，才能避免内存泄漏。那有没有别的workaround呢？仔细分析sarama中metrics相关逻辑，我们会看到，sarama是在使用metrics做一些统计信息。其实，这些统计信息对于我而言，完全可以不用，如果不用，把metrics禁掉，是否可行呢？从sarama的代码中我找到的思路：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/21_use_nil_metrics.png" alt=""></p>
<p>当我们将<code>metrics.UseNilMetrics</code>设置为<code>true</code>后，我们会看到，所有类型的metrics的创建，实际上都是返回一个空的metrics:</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/22_nil_meter.png" alt=""></p>
<p>这样一来，全局的<code>arbiter.meters</code>链表就不会勾住任何内存对象，进而内存泄漏就不存在了。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这次一次有意思的内存泄漏分析之旅。以前使用C/C++开发，经常也要进行内存泄漏的定位，相对而言驾轻就熟些，第一次golang的内存泄漏定位，经历了最开始的兴奋，到各种尝试无果的失望，再到无心插柳的灵光乍现，直到最终解决问题的满足，在解决问题的同时，也对自己收获不少而高兴。回顾一下，整个分析过程，也许做到一下几点，会有助于今后遇到类似问题，更加快速的解决问题：</p>
<ol>
<li>测试工具要跟上，方便的测试工具有助于迅速重现问题，节省测试时间</li>
<li>数据收集、展现手段要够详细，既要有直观的数据统计，通过图表能够直观的帮助你察觉是否有问题，又要能通过golang提供的pprof工具集接口进一步细化数据，深入分析</li>
<li>定位要明确，在没有找到根源时，需要逐一排除。实际上在本次分析定位过程中，我一直怀疑有goroutine泄漏，花了较多时间来确认goroutine没有问题。</li>
<li>需要有足够的耐心，不断的尝试，做完善的对比。这次最终能够发现问题，也多亏自己不断的尝试不同的测试方案和手段，做比较充分的数据比对</li>
<li>找准目标仔细分析代码</li>
</ol>
<p>补充说明一点，实际上在确认内存在Broker.Open泄漏后，我就一直在“仔细”阅读代码。但是为啥就一直没看到那个<code>arbiter.meters = append(arbiter.meters, m)</code>呢。回过头，再给自己的“不仔细”找个理由，请仔细观察一下两图：</p>
<p>本次读代码使用的VSCode：<br><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/23_vscode_GetOrRegsterMeter.png" alt=""></p>
<p>另外使用的Goglang:<br><img src="http://og43lpuu1.bkt.clouddn.com/a_memory_leak/png/24_goglang_GetOrRegsterMeter.png" alt=""></p>
<p>看到差异了吗，vscode对NewMeter尽然没高亮！自己读代码的时候，以为NewMeter是变量，没注意他原来是个函数… -,-b，此时，一个论题在我脑海中浮现：《论优秀IDE对分析问题的重要性》</p>
<p>over。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/09/02/0012_a_memory_leak_detection_procedure/">一次Golang程序内存泄漏分析之旅</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">lday</a></p>
        <p><span>发布时间:</span>2017-09-02, 02:49:14</p>
        <p><span>最后更新:</span>2017-09-02, 03:12:01</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/09/02/0012_a_memory_leak_detection_procedure/" title="一次Golang程序内存泄漏分析之旅">http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/</a>
            <span class="copy-path" data-clipboard-text="原文: http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/　　作者: lday" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/09/13/0013_a_latency_identification_procedure/">
                    一次Golang程序延迟过大问题的定位过程
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/">
                    Kafka Consumer Rebalance的演进
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试工具"><span class="toc-number">1.1.</span> <span class="toc-text">测试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据采集、汇总工具"><span class="toc-number">1.2.</span> <span class="toc-text">数据采集、汇总工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#系统监控统计级别数据指标"><span class="toc-number">1.2.1.</span> <span class="toc-text">系统监控统计级别数据指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#问题定位所需的详细数据"><span class="toc-number">1.2.2.</span> <span class="toc-text">问题定位所需的详细数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取系统实时堆内存分配详细信息"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">获取系统实时堆内存分配详细信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取系统实时所有goroutine调用栈信息"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">获取系统实时所有goroutine调用栈信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取系统实时堆内存调优辅助统计信息"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">获取系统实时堆内存调优辅助统计信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他说明"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">其他说明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟场景，重现问题"><span class="toc-number">2.</span> <span class="toc-text">模拟场景，重现问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景一：完全仿照之前的测试，通过长连接执行Pub-Sub调用"><span class="toc-number">2.1.</span> <span class="toc-text">场景一：完全仿照之前的测试，通过长连接执行Pub/Sub调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景二：改用短连接执行Pub-Sub调用"><span class="toc-number">2.2.</span> <span class="toc-text">场景二：改用短连接执行Pub/Sub调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏"><span class="toc-number">2.3.</span> <span class="toc-text">场景三：单独使用Pub调用，确认是否由Pub调用引起内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏"><span class="toc-number">2.4.</span> <span class="toc-text">场景四：单独使用Sub调用，确认是否由Sub调用引起内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景五：单独使用Sub调用，长时间压力测试"><span class="toc-number">2.5.</span> <span class="toc-text">场景五：单独使用Sub调用，长时间压力测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取数据，比对分析"><span class="toc-number">3.</span> <span class="toc-text">获取数据，比对分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#确认goroutine是否泄漏"><span class="toc-number">3.1.</span> <span class="toc-text">确认goroutine是否泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#确认内存泄漏的具体位置"><span class="toc-number">3.2.</span> <span class="toc-text">确认内存泄漏的具体位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深入分析内存泄漏的逻辑"><span class="toc-number">3.3.</span> <span class="toc-text">深入分析内存泄漏的逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确认问题，解决方案"><span class="toc-number">4.</span> <span class="toc-text">确认问题，解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"一次Golang程序内存泄漏分析之旅　| lday的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://lday.me/2017/09/02/0012_a_memory_leak_detection_procedure/';
            this.page.identifier = '2017/09/02/0012_a_memory_leak_detection_procedure/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//lday.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/09/13/0013_a_latency_identification_procedure/" title="上一篇: 一次Golang程序延迟过大问题的定位过程">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/" title="下一篇: Kafka Consumer Rebalance的演进">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/0022_how_to_do_distributed_lock/">如何实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/0021_apache_kafka_firefighter/">Apache Kafka的分布式系统消防员(Controller Broker)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/21/0020_b_tree_summary/">B-Tree数据结构总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/0019_boost_share_memory_ipc/">共享内存(ipc)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/0018_cpp_atomic_summary/">C++内存屏障（内存顺序）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/0017_condition_variable_and_mutex_together/">Linux下Condition Vairable和Mutext合用的小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/0015_How_we_use_gRPC_to_build_a_client_server_system_in_Go/">我们如何在Go中使用gRPC构建C/S结构系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/">Kafka数据丢失及最新改进策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/0013_a_latency_identification_procedure/">一次Golang程序延迟过大问题的定位过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/02/0012_a_memory_leak_detection_procedure/">一次Golang程序内存泄漏分析之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/">Kafka Consumer Rebalance的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/0010_kafka_producer_analysis_01/">Kafka Procuder小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/0009_why_not_413/">为什么没有收到预期的413状态码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/0008_kafka_vs_tranditional_mq/">Kafka与传统消息中间件的差异</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/0007_elasticsearch_summary/">ElasticSearch总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/0006_boost-multi-index-container/">多维索引容器(multi_index_container)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/0005_gdb-vs-dlv/">Golang程序调试工具介绍(gdb vs dlv)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/25/0004_golang-slice-depth/">细看Go中的切片(slice)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/0003_seri-stm-etcd3/">基于etcd3的访问序列化及分布式软事务内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/0002_hi/">你好，世界</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/0001_hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 lday
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>