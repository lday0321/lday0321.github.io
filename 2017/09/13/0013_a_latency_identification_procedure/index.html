<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="lday" />



<meta name="description" content="高吞吐、低延迟，一直是后台程序追求的目标。上周，我对PubSub系统进行了内存泄漏的分析定位，这周进一步对系统处理的延迟进行了分析，找到了引起处理延迟的关键节点。">
<meta property="og:type" content="article">
<meta property="og:title" content="一次Golang程序延迟过大问题的定位过程">
<meta property="og:url" content="http://lday.me/2017/09/13/0013_a_latency_identification_procedure/index.html">
<meta property="og:site_name" content="lday的博客">
<meta property="og:description" content="高吞吐、低延迟，一直是后台程序追求的目标。上周，我对PubSub系统进行了内存泄漏的分析定位，这周进一步对系统处理的延迟进行了分析，找到了引起处理延迟的关键节点。">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/01_before_upgrade_sub_p99.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/02_after_upgrade_before_tunning_sub_p99.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/03_cpu_profile.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/04_cpu_profile_flamegraph.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/23_sigprof.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/05_cpu_profile_13sub_flamegraph.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/06_google_StackDriver_trace_details.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/09_aws_xray_tracing.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/10_go_tool_trace.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/11_30s_trace_overview.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/12_begin_with_network_data_flow.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/12_http_handler.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/13_http_handler_end.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/14_http_handler_range.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/15_range_target.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/16_target_1.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/16_target_1_code_427.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/17_targe_1_time_config.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/18_target_1_over.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/19_target_2.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/20_targe_2_code.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/21_target_2_range.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/22_after_tunning.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/27_scheduler_G_P_M.jpg">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/24_normal_scheduler.jpg">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/25_syscall_scheduler.jpg">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/26_cpuprofile_useless_for_syscall.png">
<meta property="og:updated_time" content="2020-11-22T01:43:58.756Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一次Golang程序延迟过大问题的定位过程">
<meta name="twitter:description" content="高吞吐、低延迟，一直是后台程序追求的目标。上周，我对PubSub系统进行了内存泄漏的分析定位，这周进一步对系统处理的延迟进行了分析，找到了引起处理延迟的关键节点。">
<meta name="twitter:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/01_before_upgrade_sub_p99.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="lday的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>一次Golang程序延迟过大问题的定位过程 | lday的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">lday</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Life, Coding, Funning</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aerospike/">Aerospike</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jemalloc/">Jemalloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/">Memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atomic/">atomic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boost/">boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/">cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ds-algorithm/">ds_algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/">hello</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello1/">hello1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipc/">ipc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lease/">lease</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-barriers/">memory barriers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share-memory/">share memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storage/">storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">lday, 80后IT码农一枚. 白羊座，喜热闹</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">lday</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">lday</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Life, Coding, Funning</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-0013_a_latency_identification_procedure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/13/0013_a_latency_identification_procedure/" class="article-date">
      <time datetime="2017-09-13T14:27:14.000Z" itemprop="datePublished">2017-09-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一次Golang程序延迟过大问题的定位过程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>高吞吐、低延迟，一直是后台程序追求的目标。上周，我对PubSub系统进行了内存泄漏的分析定位，这周进一步对系统处理的延迟进行了分析，找到了引起处理延迟的关键节点。</p>
<a id="more"></a>
<p>老规矩，先来看看系统现象</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/01_before_upgrade_sub_p99.png" alt=""></p>
<p>上图是在我们对PubSub进行升级之前，PubSub系统在处理一次短连接的sub请求的耗时统计（客户端通过短连接发起一次http sub请求，获得数据，并最终关闭连接，真实的业务场景下，我们会使用http长连接，从而进一步降低每一次http连接建立、断开对每一次sub请求的overheader），从图上我们可以看出，短连接sub的耗时，大致在61ms左右（Y轴右侧坐标）。</p>
<p>在对PubSub系统进行升级改造后（我们使用了新的consumer group lib），再进一步对sub耗时进行统计，悲催的事情发生了…</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/02_after_upgrade_before_tunning_sub_p99.png" alt=""></p>
<p>我擦擦擦擦擦，sub延迟耗时尽然稳定在了312ms左右，整整多了有250ms！ @@，虾米情况啊…</p>
<p>虽然，暂时不知道究竟是什么引起了延迟的激增，但我知道，这是一次体验Golang调优的好机会，乐观点，事情总会解决的。</p>
<h2 id="CPUProfile耍起来"><a href="#CPUProfile耍起来" class="headerlink" title="CPUProfile耍起来"></a>CPUProfile耍起来</h2><p>上周对内存泄漏进行定位的时候，我们已经看到了<code>net/http/pprof</code>和<code>runtime/pprof</code>的强大功能，他能帮我们采样统计程序运行时的很多数据，其中就包括了：cpuprofile。通过cpuprofile，我们就能看到程序运行耗时在哪里，将那些耗时最高的代码给我们列出来，这样一来，我们自然就能发现，是什么引起了延迟的过高。</p>
<p>通过<code>go tool pprof --seconds 30 http://127.0.0.1:9090/debug/pprof/profile</code>命令，我们可以抽取30秒的cpu采样统计信息。为发现延迟问题，我首先通过moni启动一个sub端，每2s中执行一次sub操作，以下是我们获取的cpuprofile信息：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/03_cpu_profile.png" alt=""></p>
<p>通过<code>top 20 -cum</code>按照<code>cum</code>字段进行排序（cum的含义是该函数以及该函数的内部调用的累计耗时，flat则是纯粹该函数，不包括该函数的内部调用函数），但是，我们看不错什么<strong>明显突出</strong>问题。</p>
<h3 id="尝试使用火焰图-FlameGraph"><a href="#尝试使用火焰图-FlameGraph" class="headerlink" title="尝试使用火焰图(FlameGraph)"></a>尝试使用火焰图(FlameGraph)</h3><p>通过list方式，似乎不能很直观的观察、发现问题，那么咱们换个工具，使用时下比较流行的火焰图，我们在进一步观察一把：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/04_cpu_profile_flamegraph.png" alt=""></p>
<p>火焰图，是由uber的系统工程师Brendan Gregg弄出来的，他有一本很不错的书：<a href="https://www.amazon.com/Systems-Performance-Enterprise-Brendan-Gregg/dp/0133390098/ref=la_B004GG0SEW_1_1?s=books&amp;ie=UTF8&amp;qid=1505114273&amp;sr=1-1" target="_blank" rel="external">《Systems Performance：Enterprise and the Cloud》</a>，在此基础上，uber开源了针对golang的火焰图生成工具：<a href="https://github.com/uber/go-torch" target="_blank" rel="external">go-torch</a>，火焰图实际上是在cpuprofile数据上的二次加工，他将大量的采样数据进行了归并统计，并以颜色深浅的形式体现cpu采样耗时的高低，使得使用者能够非常直观的，一眼看出，耗时的重点在哪里。</p>
<p>如上图所示，我将cpuprofile用火焰图的形式转换出来：torch.svg，但似乎还是没能看出有啥“蹊跷”之处。</p>
<h4 id="加大点压力试试"><a href="#加大点压力试试" class="headerlink" title="加大点压力试试"></a>加大点压力试试</h4><p>会不会是sub的频率太低，使得cpuprofile采样时，没能采样到? <a href="http://mycodesmells.com/post/profiling-with-pprof" target="_blank" rel="external">SIGPROF信号每10ms触发一次</a>，通过注册该信号的handler，cpuprofile执行10ms为间隔的统计数据采样:<code>runtime/proc.go</code></p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/23_sigprof.png" alt=""></p>
<p>from <a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="external">pprof api ref</a>:</p>
<blockquote>
<p>On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the <strong>SIGPROF</strong> signal, but that signal will be delivered to the main program’s SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program.</p>
</blockquote>
<p>为此， 我加到了sub的频率，由原来的1个sub，提升到13个sub（13个不同的consumer group)同时进行sub，通过go-torch生成火焰图：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/05_cpu_profile_13sub_flamegraph.png" alt=""></p>
<p>采样到的信息更多了，但搜索一番，似乎还是没能找到可疑之处！</p>
<h2 id="换个思路"><a href="#换个思路" class="headerlink" title="换个思路"></a>换个思路</h2><p>PubSub系统要求一个consumer group中的client数量不能超过一个topic的partition数量，这就限制了我们不能像测试简单http请求一样不断的加大sub请求的数量，进而提高sub的压力，提升cpuprofile采样命中的概率。既然不能通过加压的方式换取更有用的cpuprofile，我们能否换一个思路呢？ </p>
<p>之前调研微服务治理相关的分布式追踪系统时，分布式追踪的分段延迟统计功能给我留下了深刻的印象：</p>
<p>Google的StackDriver效果图：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/06_google_StackDriver_trace_details.png" alt=""></p>
<p>Amazon的X-Ray效果图：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/09_aws_xray_tracing.png" alt=""></p>
<p>从上面两张效果图，我们可以看出，分布式追踪系统能够很方便的显示每一段调用的延迟情况，帮助我们判定整个调用的延迟究竟是损耗在哪里。如果我们在分析golang程序处理延迟时，能有一个类似的工具，从调用链的角度帮我们串出整个调用处理逻辑上的延迟情况，那该有多好啊！</p>
<h2 id="Tracer很不错"><a href="#Tracer很不错" class="headerlink" title="Tracer很不错"></a>Tracer很不错</h2><p>我google，google，google…，终于找到了他：<code>go tool trace</code>。先来看张直观效果图：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/10_go_tool_trace.png" alt=""></p>
<p>重点关注Syscalls部分，里面的彩色进度条，就是在各时间点上运行于各Proc上的goroutine执行情况。</p>
<p><code>go tool trace</code>究竟是何方神圣？golang官方对他的描述，简直是粗陋无比！<a href="https://golang.org/cmd/trace/" target="_blank" rel="external">https://golang.org/cmd/trace/</a>  相信就算是你看完了，你也不会知道trace到底是什么。没关系，下面这段来自Dimtry Vyoukov的<a href="https://docs.google.com/document/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub" target="_blank" rel="external">介绍</a>会让你明晰很多：</p>
<blockquote>
<p>Go has a number of profiling tools – CPU, memory, blocking profilers; GC and scheduler tracers and heap dumper. However, profilers provide only aggregate information, for example, how much memory in total was allocated at this source line. Tracers provide very shallow information. Heap dumper gives detailed per-object information about heap contents. <font color="#FF0000">But there is nothing that gives detailed non-aggregate information about program execution – what goroutines do execute when? for how long? when do they block? where? who does unblock them? how does GC affect execution of individual goroutines?</font></p>
<p>The goal of the tracer is to be the tool that can answer these questions.</p>
</blockquote>
<p>简言之就是，cpuprofile做的是采样、聚合的工具，他告诉你的是在这段时间内，总共这个函数被调用了多少次，耗时多少，但是这些工具没有从时间的角度来串联，而tracer则是从时间的角度来串联goroutine的行为，告诉你，在什么时候，goroutine做了什么，以及执行了多长时间，阻塞在哪里。</p>
<h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>有了得力的工具，下面就是深入的分析了</p>
<h4 id="Step1-获取trace数据"><a href="#Step1-获取trace数据" class="headerlink" title="Step1: 获取trace数据"></a>Step1: 获取trace数据</h4><p>要获取trace数据，我们还是通过<code>net/http/pprof</code>提供的接口，只是之前是获取<code>/debug/pprof/heap</code>、<code>/debug/pprof/goroutine</code>等，这次是获取<code>/debug/pprof/trace</code>信息，通过：<code>curl -XGET  &quot;http://127.0.0.1:10194/debug/pprof/trace?seconds=30&quot; -o 002_trace_2017_09_08.out</code>我们将获取一个30秒的trace数据(trace_02.out)，通过<code>go tool trace 002_trace_2017_09_08.out</code>，我们将开启tracer的探索之旅：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/11_30s_trace_overview.png" alt=""></p>
<p>从上图我们可以看到，在图标的正中间，是一段有统计数据的30s区间，这里就有我们需要的数据</p>
<h4 id="Step2-定位一个事件周期"><a href="#Step2-定位一个事件周期" class="headerlink" title="Step2: 定位一个事件周期"></a>Step2: 定位一个事件周期</h4><p>既然是要分析一次sub的延迟究竟是消耗在了哪里，那么首先我们就需要从tracer上找到一个sub究竟是从哪里到哪里。sub是从一次http请求开始，到一次http响应结束。从tracer上我们首先去定位Network有数据的地方：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/12_begin_with_network_data_flow.png" alt=""></p>
<p>从这里开始，放大这个时间点的goroutine信息，我们将找到我们需要的sub开始的http handler</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/12_http_handler.png" alt=""></p>
<p>从goroutine当时的调用栈，我们可以明确的确认，这就是一个sub请求开始的地方</p>
<p>进一步的，我们需要确认一个sub请求的结束(http response结束)的地方。既然我们已经查到http请求开始的地方是在2992号Goroutine上，那我们可以通过tracer去过滤查找2992号Goroutine的踪迹，最终我们可以找到Goroutine 2992结束的地方，基本上就能对应到http response结束的地方</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/13_http_handler_end.png" alt=""></p>
<p>我们可以看看整个Goroutine 2992的生命周期</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/14_http_handler_range.png" alt=""></p>
<p>307ms和客户端统计的312ms的延时，非常接近。</p>
<h4 id="Step3-深入细节"><a href="#Step3-深入细节" class="headerlink" title="Step3: 深入细节"></a>Step3: 深入细节</h4><p>已经定位了一次sub的整个周期，那么我们可以进一步的深入进去，观察在这个周期中究竟发生了什么</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/15_range_target.png" alt=""></p>
<p>放大整个sub周期，我们会看到，真正Goroutine活动被分隔为2圆圈画出的两部分，在这两部分之外，几乎没有goroutine活动。进一步的，我们分别观察这两个区域的goroutine活动细节</p>
<h5 id="consumer启动时，release等待100ms"><a href="#consumer启动时，release等待100ms" class="headerlink" title="consumer启动时，release等待100ms"></a>consumer启动时，release等待100ms</h5><p>在第一个圆圈区域的最末尾，我们会看到如下图所示的goroutine活动：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/16_target_1.png" alt=""></p>
<p>Goroutine 3141的活动，是整个区域最后的活动，通过查看此时Goroutine 3141的堆栈信息，我们可以看到：<code>sarama-cluster.(*Consumer)/release:427</code>，这一行是在干什么？</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/16_target_1_code_427.png" alt=""></p>
<p>这是一个无法避开的waiting！waiting了多久呢？我们得查看<code>DwellTime</code>:</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/17_targe_1_time_config.png" alt=""></p>
<p>在我们的代码中，被设置成了100ms，也就是说，这里被我们强行设置成了等待100ms。进一步的，我们通过tracer上的Goroutine活动间隔，进一步确认，的确是被waiting了100ms</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/18_target_1_over.png" alt=""></p>
<h5 id="consumer启动时，fetchOffset前等待200ms"><a href="#consumer启动时，fetchOffset前等待200ms" class="headerlink" title="consumer启动时，fetchOffset前等待200ms"></a>consumer启动时，fetchOffset前等待200ms</h5><p>类似的，我们立马发现在第二个活动区域，出现了类似的waiting，只是这次wait的是200ms(DwellTime * 2):</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/19_target_2.png" alt=""></p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/20_targe_2_code.png" alt=""></p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/21_target_2_range.png" alt=""></p>
<p>基本上，我们已经可以确定，就是设置的<code>DwellTime</code>值过大，导致cosnumer在创建时，延迟过高，进而影响了整个短连接sub的延迟。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>很直观，为减低延迟，我们需要做的就是降低DwellTime。为什么代码中需要有两个DwellTime的等待呢？从代码上的注释我们可以看出，实际上，这是sarama-cluster做的一个保险措施：consumer在发生rebalance的时候，会通过这个DwellTime等待其他工作goroutine标记最后一次处理的offset，并在等待DwellTime之后，做最后一次offset提交动作。对于PubSub而言，PubSub支持两种offset提交：1. AutoCommit，每次获取消息，在PubSub端就直接完成OffsetCommit；另外一种是DelayCommit，由下一次Sub请求，来标记OffsetCommit。对于第一种offset提交，整个处理过程是非常快的（因为只涉及系统内数据的传递之后，便完成commit），此时，完全没有必要等待100ms，而对于第二种offset提交，等待多长，都不合适，因为我们无法确定两次sub的时间间隔（由于业务系统在sub之后还有自己的处理逻辑，而这个处理逻辑的时间跨度完全不定）因此，我们也无法确定一个等待时间。基于上述分析，我们可以看出，DwellTime设置过长，对PubSub而言，意义不大。DwellTime设置短带来的可能副作用是一条消息被重复消费。而PubSub本来就是支持at least once语义，即要求业务系统在业务逻辑上做好幂等处理，因此基于上述考虑，我们调整wellTime到一个较小值：5ms，只要涵盖在AutoCommit下rebalance切换的顺利。基于5ms的设置，重新测试，观测sub延迟结果</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/22_after_tunning.png" alt=""></p>
<p>2个篮圈，分别表示调整前的312ms和调整后的27ms，延迟有效降低。</p>
<h3 id="为什么cpuprofile不好使？"><a href="#为什么cpuprofile不好使？" class="headerlink" title="为什么cpuprofile不好使？"></a>为什么cpuprofile不好使？</h3><p>回过头，我们再来看看为什么cpuprofile不好使呢？ </p>
<h4 id="golang-runtime-scheduler"><a href="#golang-runtime-scheduler" class="headerlink" title="golang runtime scheduler"></a>golang runtime scheduler</h4><p>从golang 1.1开始，Dmitry Vyukov重新设计了<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!" target="_blank" rel="external">golang runtime的scheduler</a>，进而引入了G-P-M模型。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/27_scheduler_G_P_M.jpg" alt=""></p>
<p>其中，G代表一个goroutine，他包含了goroutine的执行栈信息、goroutine的状态以及其他和goroutine调度相关的重要信息。P代表逻辑的processor，是一个调度的上下文(context)。而M代表的是系统线程，他是真正执行计算的资源。M在绑定有效的P后，进入schedule循环，从P的队列中获取待调度G，从而执行G的逻辑</p>
<p>常规情况下，M, P, G之间的关系大致如下图所示：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/24_normal_scheduler.jpg" alt=""></p>
<p>灰色部分的G目前正在等待被调度，他们被存放在一个个runqueue中。每次在程序中执行go语句，就会创建一个G，并将该G加入到runqueue队列的尾部。当P发生goroutine调度时，他会从runqueue的头上取出一个G，并将G的状态信息装载到自己的上下文中，并开始执行该G的逻辑。</p>
<p>当有G在执行过程中，陷入系统调用时，M, P, G的关系会有些变化</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/25_syscall_scheduler.jpg" alt=""></p>
<p>当G0需要执行系统调用时，scheduler会将G0从上下文P中剥离出来，逻辑上的G0和对应的M0一同进入系统调用的等待，而P将重新attach到新的M1，进而执行其他待执行的goroutine，直至G0的系统调用返回，M0则有可能steal一个新的P来执行G0，又或者将G0加入到P的runqueue中</p>
<h4 id="cpuprofile只采集P上运行的信息"><a href="#cpuprofile只采集P上运行的信息" class="headerlink" title="cpuprofile只采集P上运行的信息"></a>cpuprofile只采集P上运行的信息</h4><p>从上面对schedule的描述，我们可以看出，当G0陷入系统调用时，G0与P已经剥离开来。而当我们执行cpuprofile的时候，实际上是在统计当前在各个P上执行的G，分别处于什么状态，正因为此时G0并不在任何P上，因此，我们通过cpuprofile实际上是无法统计到关于G0进入系统调用的信息</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0013_a_latency_identification_procedure/img/26_cpuprofile_useless_for_syscall.png" alt=""></p>
<p>采样只会统计到处于P上的fun1以及fun2的信息，而无法统计到syscall部分的信息。这也就是为什么，我们在之前使用cpuprofile时，未能查看到关于进入waiting的信息</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一次比较简单的latency调优过程，从中我们可以看到，cpuprofile、trace均能帮助我们定位latency相关的问题，但是两者各有侧重：</p>
<ul>
<li>cpuprofile: 侧重于统计程序各goroutine自身的运行状况，更加适用于分析针对cpu密集型逻辑导致的latency过高问题</li>
<li>trace：以goroutine整个生命周期的事件处理为主线，充分展现了各goroutine生命周期内的状态变化，能够很好的反映系统调用下goroutine的切换逻辑，更加适用于IO密集型(系统调用密集型)逻辑导致的latency过高问题</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.youtube.com/watch?v=N3PWzBeLX2M" target="_blank" rel="external">Go Profiling and Optimization</a></li>
<li><a href="https://making.pusher.com/go-tool-trace/" target="_blank" rel="external">go tool trace</a></li>
<li><a href="https://www.youtube.com/watch?v=nsM_m4hZ-bA" target="_blank" rel="external">Fighting latency: the CPU profiler is not your ally</a></li>
<li><a href="https://www.youtube.com/watch?v=mmqDlbWk_XA" target="_blank" rel="external">Go’s execution tracer</a></li>
<li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="external">The Go scheduler</a></li>
<li><a href="https://povilasv.me/go-scheduler/" target="_blank" rel="external">Go scheduler: Ms, Ps &amp; Gs</a></li>
<li><a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器</a></li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/09/13/0013_a_latency_identification_procedure/">一次Golang程序延迟过大问题的定位过程</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">lday</a></p>
        <p><span>发布时间:</span>2017-09-13, 22:27:14</p>
        <p><span>最后更新:</span>2020-11-22, 09:43:58</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/09/13/0013_a_latency_identification_procedure/" title="一次Golang程序延迟过大问题的定位过程">http://lday.me/2017/09/13/0013_a_latency_identification_procedure/</a>
            <span class="copy-path" data-clipboard-text="原文: http://lday.me/2017/09/13/0013_a_latency_identification_procedure/　　作者: lday" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/">
                    Kafka数据丢失及最新改进策略
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/09/02/0012_a_memory_leak_detection_procedure/">
                    一次Golang程序内存泄漏分析之旅
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPUProfile耍起来"><span class="toc-number">1.</span> <span class="toc-text">CPUProfile耍起来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试使用火焰图-FlameGraph"><span class="toc-number">1.1.</span> <span class="toc-text">尝试使用火焰图(FlameGraph)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加大点压力试试"><span class="toc-number">1.1.1.</span> <span class="toc-text">加大点压力试试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#换个思路"><span class="toc-number">2.</span> <span class="toc-text">换个思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tracer很不错"><span class="toc-number">3.</span> <span class="toc-text">Tracer很不错</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析过程"><span class="toc-number">3.1.</span> <span class="toc-text">分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-获取trace数据"><span class="toc-number">3.1.1.</span> <span class="toc-text">Step1: 获取trace数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-定位一个事件周期"><span class="toc-number">3.1.2.</span> <span class="toc-text">Step2: 定位一个事件周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-深入细节"><span class="toc-number">3.1.3.</span> <span class="toc-text">Step3: 深入细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#consumer启动时，release等待100ms"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">consumer启动时，release等待100ms</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#consumer启动时，fetchOffset前等待200ms"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">consumer启动时，fetchOffset前等待200ms</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案"><span class="toc-number">3.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么cpuprofile不好使？"><span class="toc-number">3.3.</span> <span class="toc-text">为什么cpuprofile不好使？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#golang-runtime-scheduler"><span class="toc-number">3.3.1.</span> <span class="toc-text">golang runtime scheduler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpuprofile只采集P上运行的信息"><span class="toc-number">3.3.2.</span> <span class="toc-text">cpuprofile只采集P上运行的信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-number">4.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"一次Golang程序延迟过大问题的定位过程　| lday的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://lday.me/2017/09/13/0013_a_latency_identification_procedure/';
            this.page.identifier = '2017/09/13/0013_a_latency_identification_procedure/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//lday.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/" title="上一篇: Kafka数据丢失及最新改进策略">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/09/02/0012_a_memory_leak_detection_procedure/" title="下一篇: 一次Golang程序内存泄漏分析之旅">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/0026_aerospike_memory_management/">Aerospike的内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/0025_aerospike_internal_put_key/">Aerospike内部逻辑：从Record Put说起</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/0024_hdfs_lease_internal/">HDFS Lease(租约)逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/">Linux内核Page Cache和Buffer Cache关系及演化历史</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/0022_how_to_do_distributed_lock/">如何实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/0021_apache_kafka_firefighter/">Apache Kafka的分布式系统消防员(Controller Broker)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/21/0020_b_tree_summary/">B-Tree数据结构总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/0019_boost_share_memory_ipc/">共享内存(ipc)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/0018_cpp_atomic_summary/">C++内存屏障（内存顺序）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/0017_condition_variable_and_mutex_together/">Linux下Condition Vairable和Mutext合用的小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/0015_How_we_use_gRPC_to_build_a_client_server_system_in_Go/">我们如何在Go中使用gRPC构建C/S结构系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/">Kafka数据丢失及最新改进策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/0013_a_latency_identification_procedure/">一次Golang程序延迟过大问题的定位过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/02/0012_a_memory_leak_detection_procedure/">一次Golang程序内存泄漏分析之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/">Kafka Consumer Rebalance的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/0010_kafka_producer_analysis_01/">Kafka Procuder小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/0009_why_not_413/">为什么没有收到预期的413状态码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/0008_kafka_vs_tranditional_mq/">Kafka与传统消息中间件的差异</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/0007_elasticsearch_summary/">ElasticSearch总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/0006_boost-multi-index-container/">多维索引容器(multi_index_container)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/0005_gdb-vs-dlv/">Golang程序调试工具介绍(gdb vs dlv)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/25/0004_golang-slice-depth/">细看Go中的切片(slice)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/0003_seri-stm-etcd3/">基于etcd3的访问序列化及分布式软事务内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/0002_hi/">你好，世界</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/0001_hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 lday
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>