<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="lday" />



<meta name="description" content="对B树的理解一直停留在概念阶段，一直也想了解一些细节。趁着过年这段时间，把《算法导论》关于B树的章节（第18章）整个过了一遍。结合书上的说明，自己实现了一把，留为总结。以下文字内容多摘自《算法导论》，伪代码部分根据我自己的理解添加了注释。">
<meta property="og:type" content="article">
<meta property="og:title" content="B-Tree数据结构总结">
<meta property="og:url" content="http://lday.me/2018/02/21/0020_b_tree_summary/index.html">
<meta property="og:site_name" content="lday的博客">
<meta property="og:description" content="对B树的理解一直停留在概念阶段，一直也想了解一些细节。趁着过年这段时间，把《算法导论》关于B树的章节（第18章）整个过了一遍。结合书上的说明，自己实现了一把，留为总结。以下文字内容多摘自《算法导论》，伪代码部分根据我自己的理解添加了注释。">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/01_B-Tree_sample.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/02_B-Tree-split-child.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/03_split_full_root.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/04_key_insert.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/05_key_delete_part_01.png">
<meta property="og:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/06_key_delete_part_02.png">
<meta property="og:updated_time" content="2018-02-24T15:09:11.737Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B-Tree数据结构总结">
<meta name="twitter:description" content="对B树的理解一直停留在概念阶段，一直也想了解一些细节。趁着过年这段时间，把《算法导论》关于B树的章节（第18章）整个过了一遍。结合书上的说明，自己实现了一把，留为总结。以下文字内容多摘自《算法导论》，伪代码部分根据我自己的理解添加了注释。">
<meta name="twitter:image" content="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/01_B-Tree_sample.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="lday的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>B-Tree数据结构总结 | lday的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">lday</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Life, Coding, Funning</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aerospike/">Aerospike</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jemalloc/">Jemalloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/">Memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atomic/">atomic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boost/">boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/">cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ds-algorithm/">ds_algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/">hello</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello1/">hello1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipc/">ipc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lease/">lease</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-barriers/">memory barriers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share-memory/">share memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storage/">storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">lday, 80后IT码农一枚. 白羊座，喜热闹</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">lday</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">lday</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Life, Coding, Funning</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-0020_b_tree_summary" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/21/0020_b_tree_summary/" class="article-date">
      <time datetime="2018-02-21T06:04:14.000Z" itemprop="datePublished">2018-02-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      B-Tree数据结构总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/b-tree/">b-tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ds-algorithm/">ds_algorithm</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>对B树的理解一直停留在概念阶段，一直也想了解一些细节。趁着过年这段时间，把《算法导论》关于B树的章节（第18章）整个过了一遍。结合书上的说明，自己实现了一把，留为总结。以下文字内容多摘自《算法导论》，伪代码部分根据我自己的理解添加了注释。</p>
<a id="more"></a>
<h1 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h1><p>一棵B树T是具有如下性质的有根树(根为T.root)</p>
<ol>
<li><p>每个结点x有如下属性</p>
<ul>
<li>x.n，表示当前存储在结点x中的关键字个数。</li>
<li>x.n的各个关键字本身：x.key<sub>1</sub>, x.key<sub>2</sub>, … 以非降序存放，使得 x.key<sub>1</sub> &le; x.key<sub>2</sub> &le; …</li>
<li>x.leaf，是一个布尔值，如果x是叶子结点，则为TRUE, 如果x为内部结点，则为FALSE。</li>
</ul>
</li>
<li><p>每个内部结点x还包含x.n+1个指向其孩子的指针x.c<sub>1</sub>, x.c<sub>2</sub>, … 。 叶子结点没有孩子结点，所以他的c<sub>i</sub>属性没有定义。</p>
</li>
<li><p>关键字x.key<sub>i</sub>对存储在各子树中的关键字进行分割：如果k<sub>i</sub>为任意一个存储在以x.c<sub>i</sub>为根的子树中的关键字，那么：<br> k<sub>1</sub> &le; x.key<sub>1</sub> &le; k<sub>2</sub> x.key<sub>2</sub> &le; … &le; x.key<sub>x.n</sub> &le; k<sub>x.n+1</sub></p>
</li>
<li><p>每个叶子结点具有相同的深度，即树的高度h</p>
</li>
<li><p>每个结点所包含的的关键字个数有上界和下界。用一个被称作<strong>B树的最小度数(minimum degree)</strong>的估计整数t(t &ge; 2)来表示这些界：</p>
<ul>
<li>除了根结点以外的每个结点必须<font color="#FF0000"><strong>至少有t-1个关键字</strong></font>。因此，除了根节点以外的每个内部结点至少有t个孩子。如果树非空，根结点至少有一个关键字。</li>
<li>每个结点<font color="#FF0000"><strong>最多包含2t-1个关键字</strong></font>。因此，一个内部节点至多可有2t个孩子。当一个结点恰好有2t-1个关键字时，称该结点是<strong>满的(full)</strong>。</li>
</ul>
</li>
</ol>
<p>二分搜索树的扩张往往是叶子节点的向下延伸，收缩往往是从叶子节点向上收缩。但是B树不太一样，他的扩张是根结点的高度增加，相反的，收缩则是根结点的高度降低。</p>
<p>t=2的B树是最简单的。每个内部结点有2个、3个或者4个孩子，即一棵2-3-4树。然而在实际中，t的值越大，B树的高度就越小。</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/01_B-Tree_sample.png" alt=""></p>
<p>BTreeNode结构定义，代码实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BTree;</div><div class="line"></div><div class="line"><span class="comment">// A BTree Node</span></div><div class="line"><span class="keyword">class</span> BTreeNode &#123;</div><div class="line">    <span class="keyword">int</span> *keys;              <span class="comment">// 当前结点的关键字列表</span></div><div class="line">    <span class="keyword">int</span> t;                  <span class="comment">// B-Tree的最小度(minimum degree)</span></div><div class="line">    BTreeNode **children;   <span class="comment">// 子结点列表</span></div><div class="line">    <span class="keyword">int</span> n;                  <span class="comment">// 当前关键字数量（我把他称作当前结点的度）</span></div><div class="line">    <span class="keyword">bool</span> leaf;              <span class="comment">// 是否为叶子结点</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf);</div><div class="line"></div><div class="line">    <span class="comment">// 基于当前结点完成子树遍历</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 基于当前结点搜索关键字k，如果找不到则返回nullptr</span></div><div class="line">    <span class="function">BTreeNode *<span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 辅助函数，用于将当前结点的第i个子结点分裂开来</span></div><div class="line">    <span class="comment">// y结点是一个满结点</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode *y)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 辅助函数，用于向当前结点中插入一个关键字</span></div><div class="line">    <span class="comment">// 调用该函数的前提假设是，当前结点是非满结点</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNonFull</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 辅助函数，在当前结点上找到第一个大于等于目标关键字k的索引位置</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKey</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">/* 处理删除关键字的场景1                         */</span></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">// 从当前结点（叶子结点）上移除第idx位的关键字(k),(1)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeFromLeaf</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">/* 处理删除关键字的场景2                         */</span></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">// 在当前结点上，获得第idx位关键字的前驱关键字(k'),(2.a)</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPred</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 在当前结点上，获取第idx位关键爱你字的后继关键字(k'),(2.b)</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSucc</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 把第idx个子结点和第idx+1个子结点，以及第idx个关键字合并</span></div><div class="line">    <span class="comment">// 这个合并的前提应该是第idx个关键字k的左右两个子结点都只包含t-1的度(2.c/3.b)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 从当前结点（非叶子结点）上移除第idx位的关键字(k), (2)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeFromNonLeaf</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">/* 处理删除关键字的场景3                         */</span></div><div class="line">    <span class="comment">/*********************************************/</span></div><div class="line">    <span class="comment">// 关键字在第idx个子结点上，且该子结点只有t-1的度</span></div><div class="line">    <span class="comment">// 但是该子结点的左兄弟有至少t的度，则从他的左兄弟(prev)</span></div><div class="line">    <span class="comment">// 借一个关键字（左兄弟上的最大关键字）提升到当前结点</span></div><div class="line">    <span class="comment">// 把当前结点上介于左兄弟和目标子结点之间的关键字下降到目标子结点(3.a)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">borrowFromPrev</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 关键字在第idx个子结点上，且该子结点只有t-1的度</span></div><div class="line">    <span class="comment">// 但是该子结点的右兄弟有至少t的度，则从他的右兄弟(next)</span></div><div class="line">    <span class="comment">// 借一个关键字（右兄弟上的最小关键字）提升到当前结点</span></div><div class="line">    <span class="comment">// 把当前结点上介于目标子结点和右兄弟之间的关键字下降到目标子结点(3.a)</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">borrowFromNext</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 目标关键字不在当前结点上，idx是我们需要进一步第归的目标关键字</span></div><div class="line">    <span class="comment">// 可能在的第idx个子结点，通过fill保证children[idx]的度不低于t</span></div><div class="line">    <span class="comment">// 其处理了两中场景：3.a和3.b</span></div><div class="line">    <span class="comment">// 3.a: 虽然children[idx]只有t-1的度，但是他有兄弟是t及以上的</span></div><div class="line">    <span class="comment">//      通过旋转，完成子结点的度提升</span></div><div class="line">    <span class="comment">// 3.b: children和他兄弟都只有t-1的度，就通过merge来完成子结点度的提升</span></div><div class="line">    <span class="comment">// 返回fill之后的目标分支</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 基于当前结点删除关键字k</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 让BTree成为BTreeNode的友元</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> BTree;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BTreeNode::BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf) &#123;</div><div class="line">    t = <span class="keyword">_t</span>;</div><div class="line">    leaf = _leaf;</div><div class="line"></div><div class="line">    <span class="comment">// 根据t分配关键字的最大空间，关键字按升序偏序组织</span></div><div class="line">    keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*t<span class="number">-1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 根据t分配子结点的最大空间</span></div><div class="line">    children = <span class="keyword">new</span> BTreeNode *[<span class="number">2</span>*t];</div><div class="line"></div><div class="line">    <span class="comment">// 初始阶段当前结点的关键字数量为0</span></div><div class="line">    n = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BTree结构定义，代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BTreeNode;</div><div class="line"></div><div class="line"><span class="comment">// A BTree</span></div><div class="line"><span class="keyword">class</span> BTree &#123;</div><div class="line">    BTreeNode *root;    <span class="comment">// 根结点</span></div><div class="line">    <span class="keyword">int</span> t;              <span class="comment">// 最小度</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BTree(<span class="keyword">int</span> <span class="keyword">_t</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 遍历整个B-Tree</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 在B-Tree中查找某个关键字</span></div><div class="line">    <span class="function">BTreeNode *<span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 向B-Tree中插入关键字</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BTree::BTree(<span class="keyword">int</span> <span class="keyword">_t</span>) &#123;</div><div class="line">    root = <span class="literal">nullptr</span>;</div><div class="line">    t = <span class="keyword">_t</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="B树的基本操作"><a href="#B树的基本操作" class="headerlink" title="B树的基本操作"></a>B树的基本操作</h1><p>对于磁盘读写的约定：</p>
<ol>
<li>B树的根结点始终在主存中，这样无需对根做DISK-READ操作；然而，当根结点被修改后需要对根结点做一次DISK-WRITE操作。</li>
<li>任何被当做参数的结点在被传递之前，都要对他们先做一次DISK-READ操作。</li>
</ol>
<h2 id="搜索B树"><a href="#搜索B树" class="headerlink" title="搜索B树"></a>搜索B树</h2><p>B-TREE-SEARCH是定义在二叉搜索树上的TREE-SEARCH过程的一个直接扩展。他的输入是一个指向某子树根结点x的指针，以及要在该子树中搜索的一个关键字k。因此顶层调用的形式为B-TREE-SEARCH(T.root, k)。如果k在B树中，那么B-TREE-SEARCH返回的是由节点y和使得y.key<sub>i</sub>=k的下标i(i表示的是结点y上的第i个slot)组成的有序对(y, i)；否则，过程返回NIL。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">B-TREE-SEARCH(x, k):</div><div class="line">i = 1</div><div class="line">while i &lt;= x.n and k &gt; x.key_i  // 在结点x这一层，遍历所有排好序的slot，找到k应该在的恰当位置</div><div class="line">    i = i + 1</div><div class="line">if i &lt;= x.n and k == x.key_i // 相当，则意味着正好找到了！</div><div class="line">    return (x, i)</div><div class="line">elsif x.leaf // 如果已经是叶子结点了， 说明已经到底了，找不到，返回NIL</div><div class="line">    return NIL</div><div class="line">else DISK-READ(x, c_i) // 此时的x.key_i是大于k的第一个结点，因此应该沿着x.key_i的左手边，也就是c_i这个子结点，继续递归下去</div><div class="line">    return B-TREE-SEARCH(x.c_i, k)</div></pre></td></tr></table></figure></p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查找指定关键字</span></div><div class="line">BTreeNode *BTreeNode::search(<span class="keyword">int</span> k) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 在当前结点上找到大于等于k的关键字(keys是按照升序偏序，&lt;=... &lt;=... 来组织)</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( i &lt; n &amp;&amp; k &gt; keys[i])</div><div class="line">        i++;</div><div class="line"></div><div class="line">    <span class="comment">// 如果正好找到， 则返回</span></div><div class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; keys[i] == k)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前结点已经是叶子结点了， 但还是没找到，则返回nullptr</span></div><div class="line">    <span class="keyword">if</span> (leaf == <span class="literal">true</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 其他情况下， 则基于找到的大于k的最小子结点进行第归</span></div><div class="line">    <span class="keyword">return</span> children[i]-&gt;search(k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在B-Tree上查找</span></div><div class="line">BTreeNode *BTree::search(<span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">return</span> root-&gt;search(k);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>遍历B树的代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历结点</span></div><div class="line"><span class="keyword">void</span> BTreeNode::traverse() &#123;</div><div class="line">    <span class="comment">// 一个结点包含了n个关键字，同时也有n+1个子结点</span></div><div class="line">    <span class="comment">// 遍历的时候， 我们首先输出关键字左侧的子结点，然后输出当前关键字，最后再输出关键字右侧的子结点</span></div><div class="line">    <span class="comment">// 这样的遍历，才会是有序的</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="comment">// 如果不是叶子结点，那么就存在子结点</span></div><div class="line">        <span class="keyword">if</span> (leaf == <span class="literal">false</span>) &#123;</div><div class="line">            children[i]-&gt;traverse();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 在遍历完左侧子结点之后，再遍历当前关键字</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 上面遍历是children[0]-&gt;keys[0]-&gt;children[1]-&gt;keys[1]-&gt;...-&gt;children[n-1]-&gt;keys[n-1]</span></div><div class="line">    <span class="comment">// 还少了最后一个child: children[n]</span></div><div class="line">    <span class="keyword">if</span> (leaf == <span class="literal">false</span>) &#123;</div><div class="line">        children[i]-&gt;traverse();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 遍历整个B-Tree</span></div><div class="line"><span class="keyword">void</span> BTree::traverse() &#123;</div><div class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</div><div class="line">        root-&gt;traverse();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建一棵空的B树"><a href="#创建一棵空的B树" class="headerlink" title="创建一棵空的B树"></a>创建一棵空的B树</h2><p>为创建一个B树T，先用B-TREE-CREATE来创建一个空的根结点，后续，则可以通过B-TREE-INSERT向T中添加新的关键字。创建树的过程中需要用到辅助过程ALLOCATE-NODE()，他在O(1)时间内为一个新结点分配一个磁盘页。我们可以假定由ALLOCATE-NODE所创建的节点并不需要DISK-READ，因为磁盘上还没有关于该结点的有用信息。</p>
<p>伪代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">B-TREE-CREATE(T)</div><div class="line">    x = ALLOCATE-NODE()</div><div class="line">    x.leaf = TRUE</div><div class="line">    x.n = 0</div><div class="line">    DISK-WRITE(x)</div><div class="line">    T.root = x</div></pre></td></tr></table></figure></p>
<p>该部分代码实现，在<code>BTree::insert</code>接口中一并实现。</p>
<h2 id="向B树中插入一个关键字"><a href="#向B树中插入一个关键字" class="headerlink" title="向B树中插入一个关键字"></a>向B树中插入一个关键字</h2><p>由于不能将关键字插入一个满的叶结点，故引入一个操作，将一个满的结点y(<strong>2t-1</strong>个关键字)按其<strong>中间关键字</strong>(median key): y.key<sub>t</sub><strong>分裂(split)</strong>为两个各含t-1个关键字的结点。中间关键字被提升到y的父结点，以标识两棵树的划分点。但如果y的父结点也是满的，就必须在插入行的关键字之前将其分裂，最终满结点的分裂会沿着树向上传播。</p>
<p>与一棵二叉搜索树一样，可以在从树根到椰子这个单程乡下过程中将一个新的关键字插入B树中。为了做到这一点，我们并不是等到找出插入过程中实际要分裂的满结点时才做分裂。相反，当沿着树往下查找新的关键字所属位置时，就分裂沿途遇到的每个满结点（包括叶节点本身）因此，每当要分裂一个满结点y时，就能确保他的父结点不是满的</p>
<h3 id="分裂B树中的结点"><a href="#分裂B树中的结点" class="headerlink" title="分裂B树中的结点"></a>分裂B树中的结点</h3><p>B-TREE-SPLIT-CHILD的输入是一个非满的内部结点x(假定在主存中)和一个使x.c<sub>i</sub>(也假定在主存中)为x的满子结点的下标i。（x.c<sub>i</sub>是x下面的一个子结点，现在的装填是：x.c<sub>i</sub>已经满了，得把他分裂掉）。该过程把这个子结点分裂成2个，并调整x,使x包好多出来的孩子。要分裂一个满的根，首先要让根成为一个新的空节点的孩子，这样才能使用B-TREE-SPLIT-CHILD，树的高度因此增加1；分裂是树长高的唯一途径。</p>
<p>分裂动作，还没有开始插入， 他仅仅是单纯的将一个满的(2t-1)节点，变成两个非满节点(t-1)，同时，将中间key，提升到父结点中。 2t-1 = 2*(t-1) + 1</p>
<p>下图显示了这个过程。分裂一个t=4的节点（最大：2t-1=7）。结点y=x.c<sub>i</sub>按照其中间关键字S进行分为两个结点y和z，y中的哪些大于中间关键字的关键字都置于新的节点z中，他成为x的一个新的孩子，y的中间关键字S被提升到y的父结点x中。</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/02_B-Tree-split-child.png" alt=""></p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">B-TREE-SPLIT-CHILD(x, i)</div><div class="line">    z = ALLOCATE-NODE()  // 准备一个空的节点，用于存放分裂出来的，大于S的部分</div><div class="line">    y = x.c_i // 取出当前已满的x子结点y</div><div class="line">    z.leaf = y.leaf // 新结点z的leaf标签和原节点y保持一致</div><div class="line">    z.n = t - 1  // 分裂后， z的度应该只到t-1</div><div class="line">    </div><div class="line">    // 接着搬key</div><div class="line">    for j = 1 to t -1  //注意这里是到t-1</div><div class="line">        z.key_j = y.key_(j+t)  // 循环遍历，将t右侧一半的key，从y搬到z</div><div class="line">    </div><div class="line">    // 接着搬child</div><div class="line">    if not y.leaf // 如果y节点不是叶子结点，则将child部分，t右侧一半也搬到z</div><div class="line">        for j = 1 to t //注意这里是到t</div><div class="line">            z.c_j = y.c_(j+t)</div><div class="line">            </div><div class="line">    y.n = t - 1 // 分裂后，y的度由满时的2t-1缩小为t-1</div><div class="line">    </div><div class="line">    // 反着为新创建的结点z，流出一个在x上的child位置</div><div class="line">    for j = x.n+1 downto i+1  // 这个是反着copy，将i+1空出来</div><div class="line">        x.c_j+1 = x.c_j  // 顺位往后移一位，将i+1空出来</div><div class="line">    x.c_i+1 = z // 把z放在i后面一个位置，也就是紧挨着y的那个</div><div class="line">    </div><div class="line">    // 同理，还需要将key也挪一个位置，用于放S(y.key_t)</div><div class="line">    for j = x.n downto i </div><div class="line">        x.key_(j+1) = x.key_j</div><div class="line">    x.key_i = y.key_t  // 把S放在x中的新的位置</div><div class="line">    </div><div class="line">    // 因为S被提到x中，x的度提升了1</div><div class="line">    x.n = x.n + 1</div><div class="line">    </div><div class="line">    // 将x, y, z分别写回磁盘</div><div class="line">    DISK-WRITE(y)</div><div class="line">    DISK-WRITE(z)</div><div class="line">    DISK-WRITE(x)</div></pre></td></tr></table></figure></p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将当前结点的第i个子结点y分裂开来</span></div><div class="line"><span class="comment">// y结点是一个满结点</span></div><div class="line"><span class="keyword">void</span> BTreeNode::splitChild(<span class="keyword">int</span> i, BTreeNode *y) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 分配一个新的结点，用于存放分裂出来的(t-1)个关键字</span></div><div class="line">    <span class="comment">// y中被提升的中间key，在t位置，假设为s</span></div><div class="line">    BTreeNode *z = <span class="keyword">new</span> BTreeNode(t, y-&gt;leaf);</div><div class="line">    z-&gt;n = t - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 循环遍历，将y右侧的一半key，从y搬到z</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t<span class="number">-1</span>; j++) &#123;</div><div class="line">        z-&gt;keys[j] = y-&gt;keys[j+t];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接着搬child</span></div><div class="line">    <span class="keyword">if</span> (y-&gt;leaf == <span class="literal">false</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++) <span class="comment">// 注意，这里是到t</span></div><div class="line">            z-&gt;children[j] = y-&gt;children[j+t];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 分裂后，y的度数由满时的2t-1缩小为t-1</span></div><div class="line">    y-&gt;n = t - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 新创建的结点z需要加入到当前结点的子结点序列中</span></div><div class="line">    <span class="comment">// 需要将children结点往后移动一格</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= i+<span class="number">1</span>; j--) &#123;</div><div class="line">        children[j+<span class="number">1</span>] = children[j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将z放在i后面一个位置</span></div><div class="line">    children[i+<span class="number">1</span>] = z;</div><div class="line"></div><div class="line">    <span class="comment">// 同理，还需要将当前结点的key也依次向后挪一个位置</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-1</span>; j&gt;= i; j--) &#123;</div><div class="line">        keys[j+<span class="number">1</span>] = keys[j];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 把从y中分裂出来的中间的那个key，放到该位置</span></div><div class="line">    keys[i] = y-&gt;keys[t<span class="number">-1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 因为s被提升到了x中，x的度提升1</span></div><div class="line">    n = n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="以沿树单程下行方式向B树插入关键字"><a href="#以沿树单程下行方式向B树插入关键字" class="headerlink" title="以沿树单程下行方式向B树插入关键字"></a>以沿树单程下行方式向B树插入关键字</h3><p>B-TREE-INSERT利用B-TREE-SPLIT-CHILD来保证递归始终不会降至一个满结点上。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">B-TREE-INSERT(T, k)</div><div class="line">    r = T.root</div><div class="line">    if r.n == 2t - 1  // 在一个已满的根节点上插入节点，得提升高度了</div><div class="line">        s = ALLOCATE-NODE()</div><div class="line">        T.root = s    // 已这个空节点作为新的根</div><div class="line">        s.leaf = FALSE</div><div class="line">        s.n = 0</div><div class="line">        s.c1 = r  // 这个心的根只有一个子节点（原来那个满的根节点，准备分裂了）</div><div class="line">        B-TREE-SPLIT-CHILD(s, 1) // 要分裂的就是s上，第1位的子节点，原来的根结点r</div><div class="line">        </div><div class="line">        // 分裂完成之后，再在新的，不满的树上执行插入</div><div class="line">        B-TREE-INSERT-NOTFULL(s, k)</div><div class="line">    else </div><div class="line">        // 如果直接就是一颗不满的根树，则直接调用NOTFULL插入</div><div class="line">        B-TREE-INSERT-NOTFULL(r, k)</div></pre></td></tr></table></figure></p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向B-Tree中插入关键字</span></div><div class="line"><span class="keyword">void</span> BTree::insert(<span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="comment">// 如果当前B-Tree为空，则需要创建一个结点</span></div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</div><div class="line">        root = <span class="keyword">new</span> BTreeNode(t, <span class="literal">true</span>);</div><div class="line">        root-&gt;keys[<span class="number">0</span>] = k;  <span class="comment">// 该结点只有一个key，就是这个新插入的key</span></div><div class="line">        root-&gt;n = <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 判断当前根结点是否已满</span></div><div class="line">        <span class="keyword">if</span> (root-&gt;n == <span class="number">2</span>*t - <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// 如果满了，则需要提升高度</span></div><div class="line">            <span class="comment">// 分配一个新的结点，作为新的root</span></div><div class="line">            BTreeNode *s = <span class="keyword">new</span> BTreeNode(t, <span class="literal">false</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 这个新的根结点只有一个子结点，就是老的已满的根结点</span></div><div class="line">            s-&gt;children[<span class="number">0</span>] = root;</div><div class="line"></div><div class="line">            <span class="comment">// 需要对s的已满子结点进行分裂</span></div><div class="line">            s-&gt;splitChild(<span class="number">0</span>, root);</div><div class="line"></div><div class="line">            <span class="comment">// 分裂完之后，s是一个包含两个子结点的非满的结点</span></div><div class="line">            <span class="comment">// 此时，直接将k插入到s结点中</span></div><div class="line">            s-&gt;insertNonFull(k);</div><div class="line"></div><div class="line">            <span class="comment">// 最后，将s作为新的root</span></div><div class="line">            root = s;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 如果不满，则直接调用NonFull插入</span></div><div class="line">            root-&gt;insertNonFull(k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/03_split_full_root.png" alt=""></p>
<p>如上图所示，分裂t=4(2t-1=7)的根。根结点一分为二，并创建了一个新结点s。在执行B-TREE-SPLIT-CHILD(s, 1)之后，新的根包含了r的中间关键字，且以r的两半作为孩子。当根被分裂后，B树的高度增加1。</p>
<p>通过调用B-TREE-INSERT-NOTFULL完成将关键字k插入以非满根结点x为根的树中。B-TREE-INSERT-NONFULL在需要时沿树向下递归，在必要时，通过调用B-TREE-SPLIT-CHILD来保证任何时刻他所递归处理的节点都是非满的。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">B-TREE-INSERT-NONFULL(x, k)</div><div class="line">    i = x.n</div><div class="line">    if x.leaf</div><div class="line">        // 如果是叶子节点，只需要把k放到key区的合适位置就可以了</div><div class="line">        while i &gt;= 1 and k &lt; x.key_i  // i的初始位置是最后尾巴上，是整体往右移一格</div><div class="line">            x.key_(i+1) = x.key_i  // 所以最后一个slot，变到了n+1</div><div class="line">            i = i - 1</div><div class="line">    </div><div class="line">        // 此时，i的位置就是k应该放的位置的前一个位置，因为，此时k &gt;= x.key_i</div><div class="line">        // k应该放在x.key_i的后面，也就是i+1</div><div class="line">        x.key_(i+1) = k</div><div class="line">        x. n = x.n + 1 // x的度因为插入了k，而需要增加1</div><div class="line">        DISK-WRITE(x) // 对于叶子节点，处理完key区的任务，就完成了</div><div class="line">    else</div><div class="line">        // 此时应该是要搬key，同时搬child</div><div class="line">        while i &gt;= 1 and k &lt; x.key_i //同样还是要找到key的合理位置i+1</div><div class="line">            i = i - 1</div><div class="line">        i = i + 1 // 此时的i就是key应该到的位置</div><div class="line">        </div><div class="line">        // 这个时候，实际上是需要插入到i位置的child中</div><div class="line">        // 那显然，得看看child_i的度是不是已经满了</div><div class="line">        // 如果满了，为了确保一切OK，得先对child_i做split</div><div class="line">        if x.c_i.n == 2t -1 </div><div class="line">            B-TREE-SPLIT-CHILD(x, i)</div><div class="line">            </div><div class="line">            // split之后，x中会多插入一个key进来</div><div class="line">            // 这个key可能正好插在k要去的节点i的位置</div><div class="line">            // 如果正好在这里，则需要比较一下，新的节点插入之后</div><div class="line">            // k是否大于这个新的加入的节点，如果是，则需要往后挪一个</div><div class="line">            // 其实也就是插入split之前的x的第i个子节点c_i中去</div><div class="line">            if k &gt; x.key_i </div><div class="line">                i = i + 1</div><div class="line">                </div><div class="line">        //执行完上述操作之后， 我们已经可以确定：</div><div class="line">        // 1. i的位置，即x.c_i就是k需要去的子树</div><div class="line">        // 2. x.c_i是非满节点，可以继续调用NONFULL</div><div class="line">        B-TREE-INSERT-NONFULL(x.c_i, k)</div></pre></td></tr></table></figure></p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 辅助函数，用于向当前结点中插入一个关键字</span></div><div class="line"><span class="comment">// 调用该函数的前提假设是，当前结点是非满结点</span></div><div class="line"><span class="keyword">void</span> BTreeNode::insertNonFull(<span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>; <span class="comment">// 记录最右关键字位置</span></div><div class="line"></div><div class="line">    <span class="comment">// 判断是否为叶子结点</span></div><div class="line">    <span class="keyword">if</span> (leaf) &#123;</div><div class="line">        <span class="comment">// 如果是叶子结点，则直接找到一个合适的位置，将k插进去</span></div><div class="line">        <span class="comment">// 从最后面开始，如果大于k，都向后移</span></div><div class="line">        <span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; keys[i] &gt; k) &#123;</div><div class="line">            keys[i+<span class="number">1</span>] = keys[i];</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 上面循环遍历完，i的位置，是可以插入k的前一个位置</span></div><div class="line">        keys[i+<span class="number">1</span>] = k;</div><div class="line">        <span class="comment">// 度数相应加1</span></div><div class="line">        n += <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果不是叶子结点，则需要搬动key和children</span></div><div class="line">        <span class="comment">// 同样，还是得先找到key的合理位置</span></div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i] &gt; k) &#123;</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// i+1才是key应当到的子结点路径</span></div><div class="line">        i = i+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (children[i]-&gt;n == <span class="number">2</span>*t<span class="number">-1</span>) &#123;</div><div class="line">            <span class="comment">// 如果子结点已经满了，则需要切分</span></div><div class="line">            splitChild(i, children[i]);</div><div class="line"></div><div class="line">            <span class="comment">// split之后，当前结点中会多插入一个key进来</span></div><div class="line">            <span class="comment">// 这个key可能正好插在k要去的节点i的位置</span></div><div class="line">            <span class="comment">// 如果正好在这里，则需要比较一下，新的节点插入之后</span></div><div class="line">            <span class="comment">// k是否大于这个新的加入的节点，如果是，则需要往后挪一个</span></div><div class="line">            <span class="comment">// 其实也就是插入到split之前的目标子结点去</span></div><div class="line">            <span class="keyword">if</span> (keys[i] &lt; k) &#123;</div><div class="line">                ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//执行完上述操作之后， 我们已经可以确定：</span></div><div class="line">        <span class="comment">// 1. i的位置，即children[i]就是k需要去的子树</span></div><div class="line">        <span class="comment">// 2. children[i]是非满节点，可以继续调用NONFULL</span></div><div class="line">        children[i]-&gt;insertNonFull(k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如下图所示，是一个key的插入过程：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/04_key_insert.png" alt=""></p>
<p>向这个B树中插入关键字。这颗B树的最小度数t为3，那最多包含2t-1=5个关键字。在插入过程中被修改的节点由浅阴影标记：</p>
<ul>
<li>(a). B树的初始状态</li>
<li>(b). 插入B后的结果，这是一个对叶子节点的简单插入</li>
<li>(c). 接着将Q插入。节点RSTUV被分裂为2个节点，分别包好RS和UV，同时父结点由原来的GMPX变成GMPTX，最终Q被出入到左子节点RS上，变成QRS。</li>
<li>(d). 接着插入L。由于根结点现在已经满了，首先要对根结点进行分裂，树高度+1。原来的根结点GMPTX被split成：P挂GM和TX，然后L被插入到JK节点中，变成JKL</li>
<li>(e). 最后插入F, ABCDE这个节点满了，先进行分裂，分裂之后是：CGM挂AB和DE，最终F被插入到DE中，变成DEF</li>
</ul>
<h2 id="从B树中删除关键字"><a href="#从B树中删除关键字" class="headerlink" title="从B树中删除关键字"></a>从B树中删除关键字</h2><p>B树上的删除操作与插入操作类似，我们可以从任意一个节点中删除一个关键字，不仅仅是叶子结点才可以这么做。当从一个内部节点删除一个关键字时，为防止这一删除操作违反B树的性质(t-1 &le; 剩余关键字个数 &le; 2t-1)，必须保证一个结点不会在删除之后变得太小（根结点除外，他允许有比最少关键字t-1还少的关键字个数）。与插入类似， 当在要删除的关键字的路径上的结点(非根结点)，有结点只有最少(t-1)个关键字时，则需要考虑向上回溯了。</p>
<p>B-TREE-DELETE从以x为根的子树中删除关键字k。设计时，调用该函数时，必须保证无论何时，结点x递归调用自身时，x中关键字个数至少为度数t。<font color="#0000FF">注意到，这个条件要比通常B树中的最少关键字个数多1</font>，这个要求，使得在递归下降进行调用时，有时候为保证子结点的度数满足t的要求，必须在递归下降之前，将当前结点的一个关键字，移到子结点上。有了这个要求，我们就可以保证在一趟下降过程中， 我们就可以将一个关键字从树中删除，无需再向上回溯。</p>
<p>现在我们来介绍删除操作如何工作：</p>
<ol>
<li>如果关键字k在节点x中，且x是叶结点，则从x中删除</li>
<li><p>如果关键字k在节点x中，且x是内部节点，则做一下操作：<br>a. 如果结点x中，前于k的子结点为y，y至少包含了t个关键字，则找出以y为根的子树中的前驱k’。递归的删除k’，并在x中用k’代替k。（找出k’并删除他，可在沿树下降的单次递归调用中完成）</p>
<p>b.对称的，如果y有少于t个关键字，则检查x中后语k的子节点z。如果z至少有t个关键字，则找出k在以z为子树中的后继k’。递归的删除k’，并在x中用k’代替k。（同样，超出k’并删除他，可在沿树下降的单词递归调用中完成）</p>
<p>c. 否则，如果y和z都只包含t-1个关键字，则将k和z的全部合并进y，这样x就失去了k和指向z的指针，并且y现在包含2t-1个关键字。然后释放z，并递归的从y中删除k。</p>
</li>
<li><p>如果关键字k当前不在内部结点x中，则确定可能包含k的子树的根x.c<sub>i</sub>(如果k确实在树中的话)。如果x.c<sub>i</sub>只包含t-1个关键字，则必须先执行下面的3a或者3b来保证降至一个至少包含t个关键字的结点x.c<sub>i</sub>。然后，通过对x的合适的子节点x.c<sub>i</sub>进行递归而结束。</p>
<p>a. 如果x.c<sub>i</sub>只包含有t-1个关键字，但是他的一个相邻的兄弟至少包含t个关键字，则将x中的某一个关键字降至x.c<sub>i</sub>中，将x.c<sub>i</sub>的相邻的左兄弟或者右兄弟的一个关键字提升至x，将该兄弟中相应的孩子指针移到x.c<sub>i</sub>中(这个过程类似于左旋或者右旋调整，如果找了左兄弟，则将左兄弟的最大关键字提升，将x上x.c<sub>i</sub>与目标子节点之间的关键字下降到x.c<sub>i</sub>；找右兄弟的做法类似)，这样就使得x.c<sub>i</sub>增加了一个额外的关键字。</p>
<p>b. 如果x.c<sub>i</sub>以及x.c<sub>i</sub>的所有兄弟结点都只包含t-1个关键字，则将x.c<sub>i</sub>与一个兄弟结点合并，也就是将x的一个关键字移至新合并的节点，使之成为新结点的中间关键字。</p>
</li>
</ol>
<p>如图所示，是关键字的删除过程示例：</p>
<p><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/05_key_delete_part_01.png" alt=""><br><img src="http://og43lpuu1.bkt.clouddn.com/b_tree_summary/img/06_key_delete_part_02.png" alt=""></p>
<p>这课B树的最小度数t=3，因此一个结点（非根结点）包含的关键字个数最少为2(t-1)。被修改的结点都以浅阴影标记。</p>
<p>(a). 初始状态<br>(b). 删除F。这是情况1：从一个叶节点中进行简单的删除<br>(c). 删除M。这是情况2a: M的前驱L提升并占据M的位置<br>(d). 删除G。这是情况2c: G下降以构成结点DEGJK，然后从这结点中删除G，这个结点是一个叶节点，因此回到情况1，将G中心的结点DEGJK中删除–&gt;GEJK。<br>(e). 删除D。这个情况是3b：从根递归至结点CL，因为他仅有2个关键字，少于3(t)，同时CL的相邻子节点只有一个TX，他们两个都是2(t-1)。因此需要根据3b，将P下降，并与CL和TX合并，以构成CLPTX，(e’)是在合并之后的新树，根结点被剔除，树的高度减1。然后将D从这个叶节点上删除，继续下降到节点DEJK上，该结点是叶结点，直接删除，得到EJK<br>(f). 删除B。这是情况3a：AB只包含2个关键字，但是他的兄弟节点EJK包含3个关键字，因此，是将x的关键字C落下来，同时，将EJK中的E提上去（相当于左旋），之后再将ABC中的B删除–&gt;AC</p>
<p>删除关键字，针对各类场景的代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 辅助函数，在当前结点上找到第一个大于等于目标关键字k的索引位置</span></div><div class="line"><span class="keyword">int</span> BTreeNode::findKey(<span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(idx&lt;n &amp;&amp; keys[idx] &lt; k) &#123;</div><div class="line">        ++idx; <span class="comment">// 如果目标k还是太大，则继续向后找</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> idx;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从当前结点（叶子结点）上移除第idx位的关键字(k),(1)</span></div><div class="line"><span class="keyword">void</span> BTreeNode::removeFromLeaf(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="comment">// 直接将目标关键字移除（后面的关键字都往前移</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = idx+<span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">        keys[i<span class="number">-1</span>] = keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 度数也减去1</span></div><div class="line">    --n;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 在当前结点上，获得第idx位关键字的前驱关键字(k'),(2.a)</span></div><div class="line"><span class="keyword">int</span> BTreeNode::getPred(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="comment">// 找到左子树上的最大key</span></div><div class="line">    BTreeNode *cur=children[idx]; <span class="comment">// children[idx]就是第idx位关键字的前驱</span></div><div class="line"></div><div class="line">    <span class="comment">// 因为B-Tree是平衡树，所以，如果当前结点不是叶子结点，则他必有最右子结点第n位</span></div><div class="line">    <span class="keyword">while</span>(!cur-&gt;leaf) &#123;</div><div class="line">        cur = cur-&gt;children[cur-&gt;n]; <span class="comment">// 度是n，子结点数量是n+1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 最后叶子结点的最右边的key，则为最大前驱</span></div><div class="line">    <span class="keyword">return</span> cur-&gt;keys[cur-&gt;n<span class="number">-1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在当前结点上，获取第idx位关键爱你字的后继关键字(k'),(2.b)</span></div><div class="line"><span class="keyword">int</span> BTreeNode::getSucc(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="comment">// 找到右子树的最小key</span></div><div class="line">    BTreeNode *cur=children[idx+<span class="number">1</span>]; <span class="comment">// children[idx+1]就是第idx位关键字的后继结点</span></div><div class="line"></div><div class="line">    <span class="comment">// 平衡树，不是也子结点，就必须有左子结点</span></div><div class="line">    <span class="keyword">while</span>(!cur-&gt;leaf) &#123;</div><div class="line">        cur = cur-&gt;children[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 最左边的key，则为最小后继</span></div><div class="line">    <span class="keyword">return</span> cur-&gt;keys[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把第idx个子结点和第idx+1个子结点，以及第idx个关键字合并</span></div><div class="line"><span class="comment">// 这个合并的前提应该是第idx个关键字k的左右两个子结点都只包含t-1的度(2.c/3.b)</span></div><div class="line"><span class="comment">// 合并后的新结点在第idx位</span></div><div class="line"><span class="keyword">void</span> BTreeNode::merge(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    //              [idx]</div><div class="line">    //             /     \</div><div class="line">    //        (idx)     (idx+1)</div><div class="line">    */</div><div class="line">    BTreeNode *child = children[idx];</div><div class="line">    BTreeNode *sibling = children[idx+<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// child有t-1个key, sibling也有t-1个key</span></div><div class="line">    <span class="comment">// 目的是将sibling和目标关键字(keys[idx])合到child</span></div><div class="line">    <span class="comment">// [child.keys]-[keys[idx]]-[sibling.keys]</span></div><div class="line">    <span class="comment">// 目标关键字，在child上应该是在第t-1位</span></div><div class="line">    child-&gt;keys[t<span class="number">-1</span>] = keys[idx];</div><div class="line"></div><div class="line">    <span class="comment">// 接着把sibling的keys也copy过来</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;sibling-&gt;n; ++i) &#123;</div><div class="line">        child-&gt;keys[t+i] = sibling-&gt;keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// copy完keys，还要copy子树部分</span></div><div class="line">    <span class="keyword">if</span> (!child-&gt;leaf) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sibling-&gt;n; ++i) &#123;</div><div class="line">            child-&gt;children[t+i] = sibling-&gt;children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 合并后的左子树，度数变为2t-1</span></div><div class="line">    child-&gt;n += sibling-&gt;n + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 现在已经把左子树，目标关键字，右子树合成了一个新的结点（左子树）</span></div><div class="line">    <span class="comment">// 接着需要将目标关键字在当前结点上移除</span></div><div class="line">    <span class="comment">// 首先移动keys部分</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = idx+<span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">        keys[i<span class="number">-1</span>] = keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接着把子树也向左移动一格</span></div><div class="line">    <span class="comment">// idx位置的左子树不变，idx+1位置的右子树已经被合并调了</span></div><div class="line">    <span class="comment">// 移动是从idx+2移到idx+1开始</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">2</span>; i &lt;= n; ++i) &#123;</div><div class="line">        children[i<span class="number">-1</span>] = children[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 当前结点，由于去掉了一个目标结点，合并了两个子树到一个子树</span></div><div class="line">    <span class="comment">// 度数需要-1</span></div><div class="line">    n--;</div><div class="line"></div><div class="line">    <span class="comment">// 合并完之后,右子树被释放</span></div><div class="line">    <span class="keyword">delete</span>(sibling);</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从当前结点（非叶子结点）上移除第idx位的关键字(k), (2)</span></div><div class="line"><span class="keyword">void</span> BTreeNode::removeFromNonLeaf(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="keyword">int</span> k = keys[idx]; <span class="comment">// 暂存目标关键字</span></div><div class="line"></div><div class="line">    <span class="comment">// 判断左子树是否满足&gt;=t的度数条件</span></div><div class="line">    <span class="keyword">if</span> (children[idx]-&gt;n &gt;= t) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 从左子树找最大前驱</span></div><div class="line">        <span class="keyword">int</span> pred = getPred(idx);</div><div class="line">        <span class="comment">// 在左子树上，将pred(k')删除</span></div><div class="line">        children[idx]-&gt;remove(pred);</div><div class="line">        <span class="comment">// 再将k替换为k'</span></div><div class="line">        keys[idx] = pred;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children[idx+<span class="number">1</span>]-&gt;n &gt;= t) &#123;</div><div class="line">        <span class="comment">// 判断有子树是否满足&gt;=t的度数条件</span></div><div class="line"></div><div class="line">        <span class="comment">// 从右子树找最小后继</span></div><div class="line">        <span class="keyword">int</span> succ = getSucc(idx);</div><div class="line">        <span class="comment">// 在右子树上，将succ(k')删除</span></div><div class="line">        children[idx+<span class="number">1</span>]-&gt;remove(succ);</div><div class="line">        <span class="comment">// 再将k替换为k'</span></div><div class="line">        keys[idx] = succ;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果左子树和右子树的度数都仅位t-1，则需要将左子树和右子树以及目标关键字左合并</span></div><div class="line">        merge(idx);</div><div class="line">        <span class="comment">// 继而在合并的结点上进行第归删除</span></div><div class="line">        children[idx]-&gt;remove(k);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关键字在第idx个子结点上，且该子结点只有t-1的度</span></div><div class="line"><span class="comment">// 但是该子结点的左兄弟有至少t的度，则从他的左兄弟(prev)</span></div><div class="line"><span class="comment">// 借一个关键字（左兄弟上的最大关键字）提升到当前结点</span></div><div class="line"><span class="comment">// 把当前结点上介于左兄弟和目标子结点之间的关键字下降到目标子结点(3.a)</span></div><div class="line"><span class="keyword">void</span> BTreeNode::borrowFromPrev(<span class="keyword">int</span> idx) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 目标子树是第idx位，因此要从当前结点移到目标结点的关键字是第idx-1位的关键字</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    //              [idx-1][idx]</div><div class="line">    //             /      |      \</div><div class="line">    //      (idx-1)      (idx)     (idx+1)</div><div class="line">    */</div><div class="line">    BTreeNode *child = children[idx];</div><div class="line">    BTreeNode *prev = children[idx<span class="number">-1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 首先是把child子树上的关键字，全部往后面挪一位，让出空间给准备从当前结点第idx-1位下降下来的关键字</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = child-&gt;n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        child-&gt;keys[i+<span class="number">1</span>] = child-&gt;keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果是child不是叶子结点，则child的子树，也得往后挪一位</span></div><div class="line">    <span class="keyword">if</span> (!child-&gt;leaf) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = child-&gt;n; i &gt;=<span class="number">0</span>; --i)&#123;</div><div class="line">            child-&gt;children[i+<span class="number">1</span>] = child-&gt;children[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 挪好之后，把目标关键字移下来</span></div><div class="line">    child-&gt;keys[<span class="number">0</span>] = keys[idx<span class="number">-1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 别忘了，这个时候，child的第0为的子树被往后移了一格，已经空了</span></div><div class="line">    <span class="comment">// 我们需要将prev的最后一个子树挂过来</span></div><div class="line">    <span class="keyword">if</span> (!child-&gt;leaf) &#123;</div><div class="line">        child-&gt;children[<span class="number">0</span>] = prev-&gt;children[prev-&gt;n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 显然挂完之后，child的度多1</span></div><div class="line">    child-&gt;n += <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 接着，prev的最后一个key(第n-1位)要上移到当前结点的idx-1的位置</span></div><div class="line">    keys[idx<span class="number">-1</span>] = prev-&gt;keys[prev-&gt;n<span class="number">-1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// prev子结点由于上移了一个关键字，度数减1</span></div><div class="line">    <span class="comment">// 度数减一之后，原来最左边的那个子树，就相当于抹掉了</span></div><div class="line">    prev-&gt;n -= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 关键字在第idx个子结点上，且该子结点只有t-1的度</span></div><div class="line"><span class="comment">// 但是该子结点的右兄弟有至少t的度，则从他的右兄弟(next)</span></div><div class="line"><span class="comment">// 借一个关键字（右兄弟上的最小关键字）提升到当前结点</span></div><div class="line"><span class="comment">// 把当前结点上介于目标子结点和右兄弟之间的关键字下降到目标子结点(3.a)</span></div><div class="line"><span class="keyword">void</span> BTreeNode::borrowFromNext(<span class="keyword">int</span> idx) &#123;</div><div class="line">    <span class="comment">// 和borrowFromPrev的旋转方向正好相反</span></div><div class="line">    <span class="comment">// 目标子树是第idx位，因此要从当前结点移到目标结点的关键字是第idx位的关键字</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">    //              [idx-1][idx]</div><div class="line">    //             /      |      \</div><div class="line">    //     (idx-1)      (idx)     (idx+1)</div><div class="line">    */</div><div class="line">    BTreeNode *child = children[idx];</div><div class="line">    BTreeNode *next = children[idx+<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 把当前结点的第idx位的key移到目标子树child的keys中，放在最右侧</span></div><div class="line">    child-&gt;keys[child-&gt;n] = keys[idx];</div><div class="line"></div><div class="line">    <span class="comment">// 同时，next的最左子树需要挂到child的最右侧</span></div><div class="line">    <span class="keyword">if</span> (!child-&gt;leaf) &#123;</div><div class="line">        child-&gt;children[(child-&gt;n)+<span class="number">1</span>] = next-&gt;children[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// child子树的挪东已经完成，由于多增加了一个从当前结点落下来的key</span></div><div class="line">    <span class="comment">// 度数将增加1</span></div><div class="line">    child-&gt;n += <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 接着，当前结点的keys部分,第idx位的key需要被右子树next的第一个key替换</span></div><div class="line">    keys[idx] = next-&gt;keys[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 最后需要对右子树next进行调整</span></div><div class="line">    <span class="comment">// keys部分往左移一格</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; next-&gt;n; ++i) &#123;</div><div class="line">        next-&gt;keys[i<span class="number">-1</span>] = next-&gt;keys[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 子树部分也往左移动一个</span></div><div class="line">    <span class="keyword">if</span> (!next-&gt;leaf) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= next-&gt;n; ++i) &#123;</div><div class="line">            next-&gt;children[i<span class="number">-1</span>] = next-&gt;children[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 由于next最左边的关键字和子树被提走了，度数相应的减一</span></div><div class="line">    next-&gt;n -= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 目标关键字不在当前结点上，idx是我们需要进一步第归的目标关键字</span></div><div class="line"><span class="comment">// 可能在的第idx个子结点，通过fill保证children[idx]的度不低于t</span></div><div class="line"><span class="comment">// 其处理了两中场景：3.a和3.b</span></div><div class="line"><span class="comment">// 3.a: 虽然children[idx]只有t-1的度，但是他有兄弟是t及以上的</span></div><div class="line"><span class="comment">//      通过旋转，完成子结点的度提升</span></div><div class="line"><span class="comment">// 3.b: children和他兄弟都只有t-1的度，就通过merge来完成子结点度的提升</span></div><div class="line"><span class="comment">// 返回fill之后的目标分支</span></div><div class="line"><span class="keyword">int</span> BTreeNode::fill(<span class="keyword">int</span> idx) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> targetIdx = idx; <span class="comment">// 默认在fill之后，目标分支还是idx</span></div><div class="line"></div><div class="line">    <span class="comment">// 如果左子树度数有多，则从左子树借</span></div><div class="line">    <span class="keyword">if</span> (idx != <span class="number">0</span> &amp;&amp; children[idx<span class="number">-1</span>]-&gt;n &gt;= t) &#123;</div><div class="line">        borrowFromPrev(idx);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx != n &amp;&amp; children[idx+<span class="number">1</span>]-&gt;n &gt;= t) &#123;</div><div class="line">        <span class="comment">// 如果右子树度数有多，则从右子树借</span></div><div class="line">        borrowFromNext(idx);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果左右子树都只有t-1，没有多于的</span></div><div class="line">        <span class="comment">// 如果不是最右的子树，则将目标子树和右边的子树合并</span></div><div class="line">        <span class="comment">// 合并后，还是挂在idx位</span></div><div class="line">        <span class="keyword">if</span> (idx != n)</div><div class="line">            merge(idx);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            merge(idx<span class="number">-1</span>);  <span class="comment">// 注意，如果是在idx-1上进行的merge，则目标分支由原来的idx，变为idx-1!</span></div><div class="line">            targetIdx = idx<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> targetIdx;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基于当前结点删除关键字k</span></div><div class="line"><span class="keyword">bool</span> BTreeNode::remove(<span class="keyword">int</span> k) &#123;</div><div class="line">    <span class="comment">// 首先在当前结点上找到大于等于目标k的索引位置</span></div><div class="line">    <span class="keyword">int</span> idx = findKey(k);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (idx &lt; n &amp;&amp; keys[idx] == k) &#123;</div><div class="line">        <span class="comment">// 如果正好找到了，则进一步判断当前结点是否位叶子结点</span></div><div class="line">        <span class="keyword">if</span> (leaf) &#123;</div><div class="line">            removeFromLeaf(idx);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeFromNonLeaf(idx);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 总归是找到了，就返回true</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果没找到，那idx就是目标分支</span></div><div class="line">        <span class="keyword">if</span> (leaf) &#123;</div><div class="line">            <span class="comment">// 如果已经到叶子结点了，都没找到，则找不到该key了</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 接着判断，是否需要执行场景3的补足操作</span></div><div class="line">        <span class="keyword">if</span> (children[idx]-&gt;n &lt; t) &#123;</div><div class="line">            idx = fill(idx);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 补足之后，继续第归，在目标子树上进行移除</span></div><div class="line">        <span class="keyword">return</span> children[idx]-&gt;remove(k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">bool</span> BTree::remove(<span class="keyword">int</span> k) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</div><div class="line">    res = root-&gt;remove(k);</div><div class="line"></div><div class="line">    <span class="comment">// 如果remove完之后，度数已经降到0，则有两种情况</span></div><div class="line">    <span class="comment">// 要么已经没有数据了， 要么还有一个子结点，得降高度</span></div><div class="line">    <span class="keyword">if</span> (root-&gt;n == <span class="number">0</span>) &#123;</div><div class="line">        BTreeNode *tmp = root;</div><div class="line">        <span class="keyword">if</span> (root-&gt;leaf) &#123;</div><div class="line">            root = <span class="literal">nullptr</span>;</div><div class="line">            <span class="comment">// 什么时候root-&gt;leaf会变成true？</span></div><div class="line">            <span class="comment">// 只有在最后，先进入下面的else分支时，这个时候，root已经变成了root-&gt;children[0]</span></div><div class="line">            <span class="comment">// 而root-&gt;children[0]的leaf就是true，也就是新的root-&gt;leaf为true.</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            root = root-&gt;children[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 释放老root</span></div><div class="line">        <span class="keyword">delete</span> tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="实际运行效果"><a href="#实际运行效果" class="headerlink" title="实际运行效果"></a>实际运行效果</h1><p>针对上述代码，简单构建了两个场景：插入，删除。主要调用<code>BTree::insert</code>、<code>BTree::remove</code>、<code>BTree::search</code>和<code>BTree::traverse</code>接口，实际验证代码实现的正确性</p>
<h2 id="插入关键字"><a href="#插入关键字" class="headerlink" title="插入关键字"></a>插入关键字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertDemo</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">BTree <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 构造一个t=3(度数介于[2,5]之间)的B树</span></div><div class="line">    t.insert(<span class="number">10</span>);</div><div class="line">    t.insert(<span class="number">20</span>);</div><div class="line">    t.insert(<span class="number">5</span>);</div><div class="line">    t.insert(<span class="number">6</span>);</div><div class="line">    t.insert(<span class="number">12</span>);</div><div class="line">    t.insert(<span class="number">30</span>);</div><div class="line">    t.insert(<span class="number">7</span>);</div><div class="line">    t.insert(<span class="number">17</span>);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历B树:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> k = <span class="number">6</span>;</div><div class="line">    <span class="keyword">if</span> (t.search(k) != <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字"</span> &lt;&lt; k &lt;&lt; <span class="string">"存在"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字"</span> &lt;&lt; k &lt;&lt; <span class="string">"不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    k = <span class="number">15</span>;</div><div class="line">    <span class="keyword">if</span> (t.search(k) != <span class="literal">nullptr</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字"</span> &lt;&lt; k &lt;&lt; <span class="string">"存在"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字"</span> &lt;&lt; k &lt;&lt; <span class="string">"不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际运行效果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">遍历B树:</div><div class="line"> 5 6 7 10 12 17 20 30</div><div class="line">关键字6存在</div><div class="line">关键字15不存在</div></pre></td></tr></table></figure></p>
<p>##删除关键字<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDemo</span><span class="params">(ArgsT *pArgs)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">BTree <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 构造一个t=3(度数介于[2,5]之间)的B树</span></div><div class="line"></div><div class="line">    <span class="comment">// [1, 25]</span></div><div class="line">    t.insert(<span class="number">1</span>);</div><div class="line">    t.insert(<span class="number">3</span>);</div><div class="line">    t.insert(<span class="number">7</span>);</div><div class="line">    t.insert(<span class="number">10</span>);</div><div class="line">    t.insert(<span class="number">11</span>);</div><div class="line">    t.insert(<span class="number">13</span>);</div><div class="line">    t.insert(<span class="number">14</span>);</div><div class="line">    t.insert(<span class="number">15</span>);</div><div class="line">    t.insert(<span class="number">18</span>);</div><div class="line">    t.insert(<span class="number">16</span>);</div><div class="line">    t.insert(<span class="number">19</span>);</div><div class="line">    t.insert(<span class="number">24</span>);</div><div class="line">    t.insert(<span class="number">25</span>);</div><div class="line">    t.insert(<span class="number">26</span>);</div><div class="line">    t.insert(<span class="number">21</span>);</div><div class="line">    t.insert(<span class="number">4</span>);</div><div class="line">    t.insert(<span class="number">5</span>);</div><div class="line">    t.insert(<span class="number">20</span>);</div><div class="line">    t.insert(<span class="number">22</span>);</div><div class="line">    t.insert(<span class="number">2</span>);</div><div class="line">    t.insert(<span class="number">17</span>);</div><div class="line">    t.insert(<span class="number">12</span>);</div><div class="line">    t.insert(<span class="number">6</span>);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历B树:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试删除数据</span></div><div class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除6</span></div><div class="line">    <span class="keyword">int</span> key = <span class="number">6</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除13</span></div><div class="line">    key = <span class="number">13</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除7</span></div><div class="line">    key = <span class="number">7</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除4</span></div><div class="line">    key = <span class="number">4</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除2</span></div><div class="line">    key = <span class="number">2</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 移除16</span></div><div class="line">    key = <span class="number">16</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 尝试移除100</span></div><div class="line">    key = <span class="number">100</span>;</div><div class="line">    res = t.remove(key);</div><div class="line">    (res)?(<span class="built_in">cout</span> &lt;&lt; <span class="string">"成功移除"</span>):(<span class="built_in">cout</span> &lt;&lt; <span class="string">"失败移除"</span>); <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"移除"</span> &lt;&lt; key &lt;&lt; <span class="string">"后，遍历："</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    t.traverse();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际运行效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">遍历B树:</div><div class="line"> 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除6</div><div class="line">移除6后，遍历：</div><div class="line"> 1 2 3 4 5 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除13</div><div class="line">移除13后，遍历：</div><div class="line"> 1 2 3 4 5 7 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除7</div><div class="line">移除7后，遍历：</div><div class="line"> 1 2 3 4 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除4</div><div class="line">移除4后，遍历：</div><div class="line"> 1 2 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除2</div><div class="line">移除2后，遍历：</div><div class="line"> 1 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26</div><div class="line">成功移除16</div><div class="line">移除16后，遍历：</div><div class="line"> 1 3 5 10 11 12 14 15 17 18 19 20 21 22 24 25 26</div><div class="line">失败移除100</div><div class="line">移除100后，遍历：</div><div class="line"> 1 3 5 10 11 12 14 15 17 18 19 20 21 22 24 25 26</div></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/02/21/0020_b_tree_summary/">B-Tree数据结构总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">lday</a></p>
        <p><span>发布时间:</span>2018-02-21, 14:04:14</p>
        <p><span>最后更新:</span>2018-02-24, 23:09:11</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/02/21/0020_b_tree_summary/" title="B-Tree数据结构总结">http://lday.me/2018/02/21/0020_b_tree_summary/</a>
            <span class="copy-path" data-clipboard-text="原文: http://lday.me/2018/02/21/0020_b_tree_summary/　　作者: lday" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/11/06/0021_apache_kafka_firefighter/">
                    Apache Kafka的分布式系统消防员(Controller Broker)
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/12/17/0019_boost_share_memory_ipc/">
                    共享内存(ipc)的使用
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#B树的定义"><span class="toc-number">1.</span> <span class="toc-text">B树的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B树的基本操作"><span class="toc-number">2.</span> <span class="toc-text">B树的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#搜索B树"><span class="toc-number">2.1.</span> <span class="toc-text">搜索B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一棵空的B树"><span class="toc-number">2.2.</span> <span class="toc-text">创建一棵空的B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向B树中插入一个关键字"><span class="toc-number">2.3.</span> <span class="toc-text">向B树中插入一个关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分裂B树中的结点"><span class="toc-number">2.3.1.</span> <span class="toc-text">分裂B树中的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以沿树单程下行方式向B树插入关键字"><span class="toc-number">2.3.2.</span> <span class="toc-text">以沿树单程下行方式向B树插入关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从B树中删除关键字"><span class="toc-number">2.4.</span> <span class="toc-text">从B树中删除关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实际运行效果"><span class="toc-number">3.</span> <span class="toc-text">实际运行效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插入关键字"><span class="toc-number">3.1.</span> <span class="toc-text">插入关键字</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"B-Tree数据结构总结　| lday的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://lday.me/2018/02/21/0020_b_tree_summary/';
            this.page.identifier = '2018/02/21/0020_b_tree_summary/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//lday.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/11/06/0021_apache_kafka_firefighter/" title="上一篇: Apache Kafka的分布式系统消防员(Controller Broker)">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/12/17/0019_boost_share_memory_ipc/" title="下一篇: 共享内存(ipc)的使用">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/0026_aerospike_memory_management/">Aerospike的内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/0025_aerospike_internal_put_key/">Aerospike内部逻辑：从Record Put说起</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/0024_hdfs_lease_internal/">HDFS Lease(租约)逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/">Linux内核Page Cache和Buffer Cache关系及演化历史</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/0022_how_to_do_distributed_lock/">如何实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/0021_apache_kafka_firefighter/">Apache Kafka的分布式系统消防员(Controller Broker)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/21/0020_b_tree_summary/">B-Tree数据结构总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/0019_boost_share_memory_ipc/">共享内存(ipc)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/0018_cpp_atomic_summary/">C++内存屏障（内存顺序）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/0017_condition_variable_and_mutex_together/">Linux下Condition Vairable和Mutext合用的小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/0015_How_we_use_gRPC_to_build_a_client_server_system_in_Go/">我们如何在Go中使用gRPC构建C/S结构系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/">Kafka数据丢失及最新改进策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/0013_a_latency_identification_procedure/">一次Golang程序延迟过大问题的定位过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/02/0012_a_memory_leak_detection_procedure/">一次Golang程序内存泄漏分析之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/">Kafka Consumer Rebalance的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/0010_kafka_producer_analysis_01/">Kafka Procuder小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/0009_why_not_413/">为什么没有收到预期的413状态码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/0008_kafka_vs_tranditional_mq/">Kafka与传统消息中间件的差异</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/0007_elasticsearch_summary/">ElasticSearch总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/0006_boost-multi-index-container/">多维索引容器(multi_index_container)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/0005_gdb-vs-dlv/">Golang程序调试工具介绍(gdb vs dlv)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/25/0004_golang-slice-depth/">细看Go中的切片(slice)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/0003_seri-stm-etcd3/">基于etcd3的访问序列化及分布式软事务内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/0002_hi/">你好，世界</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/0001_hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 lday
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>