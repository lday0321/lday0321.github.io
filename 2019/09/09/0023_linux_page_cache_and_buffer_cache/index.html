<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="lday" />



<meta name="description" content="在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作，该操作会将文件关联的脏页(dirty page)数据(实际文件内容及元数据信息)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache)。
块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。他缓存部分磁盘数据，当有磁盘读取请求时，会首先查看块缓存">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核Page Cache和Buffer Cache关系及演化历史">
<meta property="og:url" content="http://lday.me/2019/09/09/0023_linux_page_cache_and_buffer_cache/index.html">
<meta property="og:site_name" content="lday的博客">
<meta property="og:description" content="在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作，该操作会将文件关联的脏页(dirty page)数据(实际文件内容及元数据信息)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache)。
块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。他缓存部分磁盘数据，当有磁盘读取请求时，会首先查看块缓存">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/27_file_page_device_block.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/28_linux-2.6.18_page_cache_buffer_cache.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/29_linux-2.6.18_inode_mapping.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/30_linux_kernel_radix_tree_1.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/31_linux_kernel_radix_tree_2.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/01_linux-0.11_buffer_head.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/08_linux-0.11_buffer_init.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/02_linux-0.11_getblk.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/03_linux-0.11_file_read.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/04_linux-0.11_file_write.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/05_linux-0.11_bread.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/12_linux-2.2.16_buffer_head.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/09_linux-2.2.16_buffer_init.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/10_linux-2.2.16_grow_buffers.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/11_linux-2.2.16_create_buffers.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/06_linux-2.2.16_sysv_file_write.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/07_linux-2.2.16_sysv_file_read.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/13_linux-2.2.16_getblk.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/14_linux-2.2.16_page_cache_and_buffer_cache.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/15_linux-2.4.0_page_cache_and_buffer_cache.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/24_linux-2.4.0_page.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/25_linux-2.4.0_buffer_head.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/26_linux-2.4.0_page_and_buffer_head.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/18_linux-2.4.0_generic_file_write.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/19_linux-2.4.0_block_prepare_write.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/21_linux-2.4.0_create_empty_buffers.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/22_linux-2.4.0-create_buffers.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/23_linux-2.4.0-set_bh_page.png">
<meta property="og:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/17_linux-2.4.0_file_block_page_cache.png">
<meta property="og:updated_time" content="2019-09-08T17:22:10.145Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核Page Cache和Buffer Cache关系及演化历史">
<meta name="twitter:description" content="在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作，该操作会将文件关联的脏页(dirty page)数据(实际文件内容及元数据信息)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache)。
块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。他缓存部分磁盘数据，当有磁盘读取请求时，会首先查看块缓存">
<meta name="twitter:image" content="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/27_file_page_device_block.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="lday的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Linux内核Page Cache和Buffer Cache关系及演化历史 | lday的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">lday</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Life, Coding, Funning</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aerospike/">Aerospike</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jemalloc/">Jemalloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/">Memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atomic/">atomic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/">b-tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boost/">boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/">cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrency/">concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ds-algorithm/">ds_algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/">hello</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello1/">hello1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipc/">ipc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lease/">lease</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-barriers/">memory barriers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share-memory/">share memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storage/">storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">lday, 80后IT码农一枚. 白羊座，喜热闹</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">lday</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/assets/blogImg/donkey.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">lday</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Life, Coding, Funning</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:oneday0321@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/lday0321" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-0023_linux_page_cache_and_buffer_cache" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/" class="article-date">
      <time datetime="2019-09-08T16:55:14.000Z" itemprop="datePublished">2019-09-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux内核Page Cache和Buffer Cache关系及演化历史
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cache/">cache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/storage/">storage</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作，该操作会将文件关联的脏页(dirty page)数据(实际文件内容及元数据信息)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache)。</p>
<p>块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。他缓存部分磁盘数据，当有磁盘读取请求时，会首先查看块缓存中是否有对应的数据，如果有的话，则直接将对应数据返回，从而减少对磁盘的访问。</p>
<p>两层缓存各有自己的缓存目标，我好奇的是，这两者到底是什么关系。本文主要参考若干kernel资料，对应的kernel源码版本主要包括：linux-0.11, linux-2.2.16, linux-2.4.0, linux-2.4.19, linux-2.6.18。</p>
<a id="more"></a>
<h1 id="两类缓存各自的作用"><a href="#两类缓存各自的作用" class="headerlink" title="两类缓存各自的作用"></a>两类缓存各自的作用</h1><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>Page Cache以Page为单位，缓存文件内容。缓存在Page Cache中的文件数据，能够更快的被用户读取。同时对于带buffer的写入操作，数据在写入到Page Cache中即可立即返回，而不需等待数据被实际持久化到磁盘，进而提高了上层应用读写文件的整体性能。</p>
<h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h2><p>磁盘的最小数据单位为sector，每次读写磁盘都是以sector为单位对磁盘进行操作。sector大小跟具体的磁盘类型有关，有的为512Byte， 有的为4K Bytes。无论用户是希望读取1个byte，还是10个byte，最终访问磁盘时，都必须以sector为单位读取，如果裸读磁盘，那意味着数据读取的效率会非常低。同样，如果用户希望向磁盘某个位置写入(更新)1个byte的数据，他也必须整个刷新一个sector，言下之意，则是在写入这1个byte之前，我们需要先将该1byte所在的磁盘sector数据全部读出来，在内存中，修改对应的这1个byte数据，然后再将整个修改后的sector数据，一口气写入磁盘。为了降低这类低效访问，尽可能的提升磁盘访问性能，内核会在磁盘sector上构建一层缓存，他以sector的整数倍力度单位(block)，缓存部分sector数据在内存中，当有数据读取请求时，他能够直接从内存中将对应数据读出。当有数据写入时，他可以直接再内存中直接更新指定部分的数据，然后再通过异步方式，把更新后的数据写回到对应磁盘的sector中。这层缓存则是块缓存Buffer Cache。</p>
<h1 id="两类缓存的逻辑关系"><a href="#两类缓存的逻辑关系" class="headerlink" title="两类缓存的逻辑关系"></a>两类缓存的逻辑关系</h1><p>从linux-2.6.18的内核源码来看，<font color="#0000FF"><strong>Page Cache和Buffer Cache是一个事物的两种表现：对于一个Page而言，对上，他是某个File的一个Page Cache，而对下，他同样是一个Device上的一组Buffer Cache</strong></font>。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/27_file_page_device_block.png" alt=""></p>
<p>File在地址空间上，以4K(page size)为单位进行切分，每一个4k都<em>可能</em>对应到一个page上（这里<em>可能</em>的含义是指，只有被缓存的部分，才会对应到page上，没有缓存的部分，则不会对应），而这个4k的page，就是这个文件的一个Page Cache。而对于落磁盘的一个文件而言，最终，这个4k的page cache，还需要映射到一组磁盘block对应的buffer cache上，假设block为1k，那么每个page cache将对应一组(4个)buffer cache，而每一个buffer cache，则有一个对应的buffer cache与device block映射关系的描述符：buffer_head，这个描述符记录了这个buffer cache对应的block在磁盘上的具体位置。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/28_linux-2.6.18_page_cache_buffer_cache.png" alt=""></p>
<p>上图只展示了Page Cache与Buffer Cache(buffer_head)，以及对应的block之间的关联关系。而从File的角度来看，要想将数据写入磁盘，第一步，则是需要找到file具体位置对应的page cache是哪个page？ 进而才能将数据写入。而要找到对应的page，则依赖于inode结构中的<code>i_mapping</code>字段：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/29_linux-2.6.18_inode_mapping.png" alt=""></p>
<p>该字段为一<code>address_space</code>结构，而实际上<code>address_space</code>即为一棵radix tree。简单来说，radix tree即为一个多级索引结构，如果将一个文件的大小，以page为单位来切分，假设一个文件有N个page，这个N是一个32bit的int，那么，这个32bit的N，可以被切分成若干层级：level-0: [0 - 7bit], level-1:[8 - 15bit], level-2: [16 - 23bit], level-3: [24 - 31bit]。在查找File某个位置对应的page是否存在时，则拿着这个page所在的位置N，到对应的radix-tree上查找。 查找时，首先通过N中的level-0部分，到radix tree上的level-0层级索引上去查找，如果不存在，则直接告知不存在，如果存在，则进一步的，拿着N中的level-1部分，到这个level-0下面对应的level-1去查找，一级一级查找。这样，我们可以看出，最多，在4层索引上查找，就能找到N对应的page信息。radix-tree及address_space的详细描述，可参考[12]、[2]中的说明。这里借用[12]、[2]中的各自一张图，可能会更好说明radix-tree(address_space)结构的样子：</p>
<p>基本的radix-tree映射结构：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/30_linux_kernel_radix_tree_1.png" alt=""></p>
<p>对应的inode上，i_mapping字段(address_space)对page的映射关系：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/31_linux_kernel_radix_tree_2.png" alt=""></p>
<h1 id="两类缓存的演进历史"><a href="#两类缓存的演进历史" class="headerlink" title="两类缓存的演进历史"></a>两类缓存的演进历史</h1><p>虽然，目前Linux Kernel代码中，Page Cache和Buffer Cache实际上是统一的，无论是文件的Page Cache还是Block的Buffer Cache最终都统一到Page上。但是，在阅读较老代码时，我们能够看出，这两块缓存的实现，原本是完全分开的。是什么原因使得最终这两类缓存“走到了一起”？[10]中各位的回答，让我豁然开来。 我试着对这一演进的由来做个梳理。</p>
<h2 id="第一阶段：仅有Buffer-Cache"><a href="#第一阶段：仅有Buffer-Cache" class="headerlink" title="第一阶段：仅有Buffer Cache"></a>第一阶段：仅有Buffer Cache</h2><p>在Linux-0.11版本的代码中，我们会看到，buffer cache是完全独立的实现，甚至都还没有基于page作为内存单元，而是以原始指针的系形式出现。每一个block sector，在kernel内部对应一个独立的buffer cache单元，这个buffer cache单元通过buffer head来描述：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/01_linux-0.11_buffer_head.png" alt=""></p>
<p>其中，buffer_head在初始化时，其内部的<code>b_data</code>指向的是原始的内存地址：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/08_linux-0.11_buffer_init.png" alt=""></p>
<p>其中，<code>b_data</code>指向具体的buffer cache内容，而<code>b_dev</code>和<code>b_blocknr</code>则代表了这块缓存对应的device以及device上的block number信息。</p>
<p>kernel通过<code>getblk</code>函数，会将一个指定dev, blocknr sector对应的buffer cache单元(buffer header)返回给调用方。上层读取、写入这个buffer_header，最终将会映射到对应(dev, blocknr) sector的读取和写入。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/02_linux-0.11_getblk.png" alt=""></p>
<p>如果一个对应的buffer cache单元(dev, blocknr)已经在kernel中分配了，则会通过<code>get_hash_table</code>直接返回给用户，如果没有，则会首先创建出对应的buffer_header，并将其加入到hash_table中(<code>inser_into_queues</code>)，最终返回给用户。</p>
<p>上层对于文件的读写，会转化到对于对应buffer_header的读写：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/03_linux-0.11_file_read.png" alt=""></p>
<p>file_read时，会先通过<code>f_pos</code>计算出实际位于的dev, blocknr位置，并通过<code>bread</code>获取到对应的<code>buffer_head</code>, 而在此之后，则会通过<code>put_fs_byte</code>完成buffer cache单元中的数据向目标buf的数据回填(数据读取)</p>
<p>同理，在向文件中写入数据时，也是通过<code>f_pos</code>首先计算出对应的dev, blocknr位置信息，进而通过<code>bread</code>拿到对应的buffer_head，并向buffer_header对应的buffer cache单元中写入数据</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/04_linux-0.11_file_write.png" alt=""></p>
<p>从上面file_read, file_write的实现来看，我们会看到<code>bread</code>返回目标buffer_head，让上层只操作buffer cache单元，而不再关心block底层。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/05_linux-0.11_bread.png" alt=""></p>
<p>而<code>bread</code>内部则是通过上面提到的<code>getblk</code>函数，返回对应的buffer_head，接着执行数据读取。</p>
<h2 id="第二阶段：Page-Cache、Buffer-Cache两者并存"><a href="#第二阶段：Page-Cache、Buffer-Cache两者并存" class="headerlink" title="第二阶段：Page Cache、Buffer Cache两者并存"></a>第二阶段：Page Cache、Buffer Cache两者并存</h2><p>到Linux-2.2版本时，磁盘文件访问的高速缓冲仍然是缓冲区高速缓冲(Buffer Cache)。其访问模式与上面Linux-0.11版本的访问逻辑基本类似。但此时，Buffer Cache已基于page来分配内存，buffer_head内部，已经有了关于所在page的一些信息：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/12_linux-2.2.16_buffer_head.png" alt=""></p>
<p>同时，从buffer cache的初始化，以及buffer cache不足时新建buffer cache单元的动作，我们也可以看出，此时buffer cache已经完全是基于page来分配内存</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/09_linux-2.2.16_buffer_init.png" alt=""></p>
<p>当buffer cache不足时，通过<code>grow_buffers</code>来新增buffer cache:</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/10_linux-2.2.16_grow_buffers.png" alt=""></p>
<p>并通过<code>create_buffers</code>来完成对buffer_head的初始化构造：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/11_linux-2.2.16_create_buffers.png" alt=""></p>
<p>以Linux-2.2.16版本的代码为例，在执行磁盘文件写入时，会通过xxx_getblk获取对应位置的<code>buffer_head</code>信息，并将对应的数据写入该buffer中。在此之后，会执行一步<strong><code>update_vm_cache</code></strong>，至于为什么会要执行这一步，我们后面再来看。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/06_linux-2.2.16_sysv_file_write.png" alt=""></p>
<p>而对于对应的文件读取，则是同样，先通过xxx_getblk找到对应的buffer_head，在此之后，完成对应的数据读取。（通过while循环，一口气将所有目标block的buffer_head拿出来，再一把读取所有的数据）</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/07_linux-2.2.16_sysv_file_read.png" alt=""></p>
<p>而xxx_getblk最终，还是使用的<code>getblk</code>接口来定位到指定的<code>buffer_head</code>:</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/13_linux-2.2.16_getblk.png" alt=""></p>
<p>从上面的描述我们可以看出，此时的buffer cache基于page来分配内存，但是与Page Cache完全独立，一点关系都没有。</p>
<p>在Linux-2.2版本中，<strong>Page Cache</strong>此时用来干什么的？</p>
<p>(1). 用于文件的mmap:</p>
<p>来自[10]:</p>
<blockquote>
<p>page cache was used to cache pages of files mapped with mmap MAP_FILE among other things.</p>
</blockquote>
<p>来自[11]:</p>
<blockquote>
<p>read() and write() are implemented using the buffer cache. The read() system call reads file data into a buffer cache buffer and then copies it to the application. <font color="#FF0000">The mmap() system call, however, has to use the page cache to store its data since the buffer cache memory is not managed by the VM system and thus not cannot be mapped into an application address space. Therefore the file data in the buffer cache is copied into page cache pages, which are then used to satisfy page faults on the application mappings.</font></p>
</blockquote>
<p>用于network-based filesytems:<br>来自[1]：</p>
<blockquote>
<p>Disk-based filesystems do not directly use the page cache for writing to a regular file. This is<br>a heritage from older versions of Linux, in which the only disk cache was the buffer cache.<br>However, network-based filesystems always use the page cache for writing to a regular file.</p>
</blockquote>
<p>此时， Page Cache和Buffer Cache的关系如下图所示：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/14_linux-2.2.16_page_cache_and_buffer_cache.png" alt=""></p>
<p>Page Cache仅负责其中mmap部分的处理，而Buffer Cache实际上负责所有对磁盘的IO访问。从上面图中，我们也可看出其中一个问题：write绕过了Page Cache，这里导致了一个同步问题。当write发生时，有效数据是在Buffer Cache中，而不是在Page Cache中。这就导致mmap访问的文件数据可能存在不一致问题。为了解决这个问题，所有基于磁盘文件系统的write，都需要调用<strong><code>update_vm_cache()</code></strong>函数，该操作会修改write相关Buffer Cache对应的Page Cache。从代码中我们可以看到，上述<code>sysv_file_write</code>中，在调用完<code>copy_from_user</code>之后，会调用<code>update_vm_cache</code></p>
<p>同样，正是这样Page Cache、Buffer Cache分离的设计，导致基于磁盘的文件，同一份数据，可能在Page Cache中有一份，而同时，却还在Buffer Cache中有一份。</p>
<h2 id="第三阶段：Page-Cache、Buffer-Cache两者融合"><a href="#第三阶段：Page-Cache、Buffer-Cache两者融合" class="headerlink" title="第三阶段：Page Cache、Buffer Cache两者融合"></a>第三阶段：Page Cache、Buffer Cache两者融合</h2><p>介于上述Page Cache、Buffer Cache分离设计的弊端，Linux-2.4版本中对Page Cache、Buffer Cache的实现进行了融合，融合后的Buffer Cache不再以独立的形式存在，Buffer Cache的内容，直接存在于Page Cache中，同时，保留了对Buffer Cache的描述符单元：<code>buffer_head</code></p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/15_linux-2.4.0_page_cache_and_buffer_cache.png" alt=""></p>
<p>page结构中，通过<code>buffers</code>字段是否为空，来判定这个Page是否与一组Buffer Cache关联（在后续的演进过程中，这个判断，转变为由<code>private</code>字段来判定）。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/24_linux-2.4.0_page.png" alt=""></p>
<p>而对应的， buffer_head则增加了字段<code>b_page</code>，直接指向对应的page。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/25_linux-2.4.0_buffer_head.png" alt=""></p>
<p>至此，两者的关系已经相互融合如下图所示：</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/26_linux-2.4.0_page_and_buffer_head.png" alt=""></p>
<p>一个文件的PageCache(page)，通过<code>buffers</code>字段能够非常快捷的确定该page对应的buffer_head信息，进而明确该page对应的device, block等信息。</p>
<p>从逻辑上来看，当针对一个文件的write请求进入内核时，会执行<code>generic_file_write</code>，在这一层，通过inode的address_space结构<code>mapping</code>会分配一个新的page来作为对应写入的page cache(这里我们假设是一个新的写入，且数据量仅一个page)：<code>__grab_cache_page</code>，而在分配了内存空间page之后，则通过<code>prepare_write</code>，来完成对应的buffer_head的构建。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/18_linux-2.4.0_generic_file_write.png" alt=""></p>
<p><code>prepare_write</code>实际执行的是：<code>__block_prepare_write</code>，在其中，会针对该page分配对应的buffer_head(<code>create_empty_buffers</code>)，并计算实际写入的在device上的具体位置：blocknr，进而初始化buffer_head(<code>get_block</code>)</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/19_linux-2.4.0_block_prepare_write.png" alt=""></p>
<p>在<code>create_empty_buffers</code>内部，则通过<code>create_buffers</code>以及<code>set_bh_page</code>等一系列操作，将page与buffer_head组织成如前图所示的通过<code>buffers</code>、<code>b_page</code>等相互关联的关系。</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/21_linux-2.4.0_create_empty_buffers.png" alt=""></p>
<p>通过<code>create_buffers</code>分配一组串联好的buffer_head</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/22_linux-2.4.0-create_buffers.png" alt=""></p>
<p>通过<code>set_bh_page</code>将各buffer_head关联到对应的page，以及data的具体位置</p>
<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/23_linux-2.4.0-set_bh_page.png" alt=""></p>
<p>正是如上的一系列动作，使得Page Cache与Buffer Cache(buffer_head)相互绑定。对上，在文件读写时，以page为单位进行处理。而对下，在数据向device进行刷新时，则可以以buffer_head(block)为单位进行处理。</p>
<p>在后续的linux-2.5版本中，引入了bio结构来替换基于buffer_head的块设备IO操作。</p>
<font color="#FF0000"><strong>[注意]</strong>：这里的Page Cache与Buffer Cache的融合，是针对文件这一层面的Page Cache与Buffer Cache的融合。对于跨层的：File层面的Page Cache和裸设备Buffer Cache，虽然都统一到了基于Page的实现，但File的Page Cache和该文件对应的Block在裸设备层访问的Buffer Cache，这两个是完全独立的Page，这种情况下，一个物理磁盘Block上的数据，仍然对应了Linux内核中的两份Page，一个是通过文件层访问的File的Page Cache(Page Cache)，一个是通过裸设备层访问的Page Cache(Buffer Cache)。</font>

<p><img src="https://lday-me-1257906058.cos.ap-shanghai.myqcloud.com/0023_linux_page_cache_and_buffer_cache/img/17_linux-2.4.0_file_block_page_cache.png" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]. Understanding the Linux Kernel<br>[2]. Professional Linux Kernel Architecture<br>[3]. The Art of Linux Kernel Design<br>[4]. Linux Kernel Development<br>[5]. A Heavily Commented Linux Kernel Source Code<br>[6]. Linux内核源代码情景分析<br>[7]. 独辟蹊径品内核：Linux内核源代码导读<br>[8]. <a href="https://www.ibm.com/developerworks/cn/linux/l-cache/index.html" target="_blank" rel="external">Linux内核的文件Cache管理机制介绍</a><br>[9]. <a href="https://ilinuxkernel.com/?p=1700" target="_blank" rel="external">Linux内核文件Cache机制</a><br>[10]. <a href="https://www.quora.com/What-is-the-major-difference-between-the-buffer-cache-and-the-page-cache-Why-were-they-separate-entities-in-older-kernels-Why-were-they-merged-later-on" target="_blank" rel="external">What is the major difference between the buffer cache and the page cache</a><br>[11]. UBC: An Efficient Unified I/O and Memory Caching Subsystem for NetBSD<br>[12]. <a href="https://lwn.net/Articles/175432/" target="_blank" rel="external">Trees I: Radix trees</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/">Linux内核Page Cache和Buffer Cache关系及演化历史</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">lday</a></p>
        <p><span>发布时间:</span>2019-09-09, 00:55:14</p>
        <p><span>最后更新:</span>2019-09-09, 01:22:10</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/" title="Linux内核Page Cache和Buffer Cache关系及演化历史">http://lday.me/2019/09/09/0023_linux_page_cache_and_buffer_cache/</a>
            <span class="copy-path" data-clipboard-text="原文: http://lday.me/2019/09/09/0023_linux_page_cache_and_buffer_cache/　　作者: lday" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/01/28/0024_hdfs_lease_internal/">
                    HDFS Lease(租约)逻辑
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/11/18/0022_how_to_do_distributed_lock/">
                    如何实现分布式锁
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#两类缓存各自的作用"><span class="toc-number">1.</span> <span class="toc-text">两类缓存各自的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Cache"><span class="toc-number">1.1.</span> <span class="toc-text">Page Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer-Cache"><span class="toc-number">1.2.</span> <span class="toc-text">Buffer Cache</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两类缓存的逻辑关系"><span class="toc-number">2.</span> <span class="toc-text">两类缓存的逻辑关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#两类缓存的演进历史"><span class="toc-number">3.</span> <span class="toc-text">两类缓存的演进历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一阶段：仅有Buffer-Cache"><span class="toc-number">3.1.</span> <span class="toc-text">第一阶段：仅有Buffer Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二阶段：Page-Cache、Buffer-Cache两者并存"><span class="toc-number">3.2.</span> <span class="toc-text">第二阶段：Page Cache、Buffer Cache两者并存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三阶段：Page-Cache、Buffer-Cache两者融合"><span class="toc-number">3.3.</span> <span class="toc-text">第三阶段：Page Cache、Buffer Cache两者融合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Linux内核Page Cache和Buffer Cache关系及演化历史　| lday的博客　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://lday.me/2019/09/09/0023_linux_page_cache_and_buffer_cache/';
            this.page.identifier = '2019/09/09/0023_linux_page_cache_and_buffer_cache/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//lday.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/01/28/0024_hdfs_lease_internal/" title="上一篇: HDFS Lease(租约)逻辑">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/11/18/0022_how_to_do_distributed_lock/" title="下一篇: 如何实现分布式锁">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/06/0027_test/">TEST</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/0026_aerospike_memory_management/">Aerospike的内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/0025_aerospike_internal_put_key/">Aerospike内部逻辑：从Record Put说起</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/0024_hdfs_lease_internal/">HDFS Lease(租约)逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/09/0023_linux_page_cache_and_buffer_cache/">Linux内核Page Cache和Buffer Cache关系及演化历史</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/0022_how_to_do_distributed_lock/">如何实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/06/0021_apache_kafka_firefighter/">Apache Kafka的分布式系统消防员(Controller Broker)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/21/0020_b_tree_summary/">B-Tree数据结构总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/17/0019_boost_share_memory_ipc/">共享内存(ipc)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/02/0018_cpp_atomic_summary/">C++内存屏障（内存顺序）总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/0017_condition_variable_and_mutex_together/">Linux下Condition Vairable和Mutext合用的小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/0016_what_is_memory_barriers/">什么是内存屏障(Memory Barriers)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/0015_How_we_use_gRPC_to_build_a_client_server_system_in_Go/">我们如何在Go中使用gRPC构建C/S结构系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/08/0014_kafka_data_loss_and_new_mechanism/">Kafka数据丢失及最新改进策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/0013_a_latency_identification_procedure/">一次Golang程序延迟过大问题的定位过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/02/0012_a_memory_leak_detection_procedure/">一次Golang程序内存泄漏分析之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/0011_kafka_consumer_rebalance_evolution/">Kafka Consumer Rebalance的演进</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/0010_kafka_producer_analysis_01/">Kafka Procuder小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/0009_why_not_413/">为什么没有收到预期的413状态码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/0008_kafka_vs_tranditional_mq/">Kafka与传统消息中间件的差异</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/0007_elasticsearch_summary/">ElasticSearch总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/0006_boost-multi-index-container/">多维索引容器(multi_index_container)的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/0005_gdb-vs-dlv/">Golang程序调试工具介绍(gdb vs dlv)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/25/0004_golang-slice-depth/">细看Go中的切片(slice)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/0003_seri-stm-etcd3/">基于etcd3的访问序列化及分布式软事务内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/0002_hi/">你好，世界</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/0001_hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2021 lday
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>